/+
 +  D bindings copyright:
 +  Copyright © 2015 Rémi Thebault
 +/
/+
 +      File generated by wayland-scanner-d v1.0.0:
 +  /home/remi/dev/wayland-scanner-d/wayland-scanner-d -m  \
 +      wayland.client.protocol --mode client --protocol -o  \
 +      ./src/wayland/client/protocol.d -x wayland.client.core -x  \
 +      wayland.client.ifaces
 +
 +  Do not edit!
 +/
/+
 +  Protocol copyright:
 +  Copyright © 2008-2011 Kristian Høgsberg
 +  Copyright © 2010-2011 Intel Corporation
 +  Copyright © 2012-2013 Collabora, Ltd.
 +
 +  Permission is hereby granted, free of charge, to any person
 +  obtaining a copy of this software and associated documentation files
 +  (the "Software"), to deal in the Software without restriction,
 +  including without limitation the rights to use, copy, modify, merge,
 +  publish, distribute, sublicense, and/or sell copies of the Software,
 +  and to permit persons to whom the Software is furnished to do so,
 +  subject to the following conditions:
 +
 +  The above copyright notice and this permission notice (including the
 +  next paragraph) shall be included in all copies or substantial
 +  portions of the Software.
 +
 +  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 +  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
 +  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 +  NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
 +  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
 +  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
 +  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 +  SOFTWARE.
 +/
module wayland.client.protocol;

import wayland.client.util;
import wayland.client.opaque_types;
import wayland.client.core;
import wayland.client.ifaces;

extern (C) {

    struct wl_registry;
    struct wl_callback;
    struct wl_compositor;
    struct wl_shm_pool;
    struct wl_shm;
    struct wl_buffer;
    struct wl_data_offer;
    struct wl_data_source;
    struct wl_data_device;
    struct wl_data_device_manager;
    struct wl_shell;
    struct wl_shell_surface;
    struct wl_surface;
    struct wl_seat;
    struct wl_pointer;
    struct wl_keyboard;
    struct wl_touch;
    struct wl_output;
    struct wl_region;
    struct wl_subcompositor;
    struct wl_subsurface;

    /++
     +  global error values
     +
     +  These errors are global and can be emitted in response to any
     +  server request.
     +/
    /++
     +  WL_DISPLAY_ERROR_INVALID_OBJECT: server couldn't find object
     +  WL_DISPLAY_ERROR_INVALID_METHOD: method doesn't exist on the specified interface
     +  WL_DISPLAY_ERROR_NO_MEMORY: server is out of memory
     +
     +/
    enum uint WL_DISPLAY_ERROR_INVALID_OBJECT = 0;
    enum uint WL_DISPLAY_ERROR_INVALID_METHOD = 1; /// ditto
    enum uint WL_DISPLAY_ERROR_NO_MEMORY = 2; /// ditto

    /++
     +  core global object
     +
     +  The core global object.  This is a special singleton object.  It
     +  is used for internal Wayland protocol features.
     +/
    struct wl_display_listener
    {
        /++
         +  fatal error event
         +
         +  The error event is sent out when a fatal (non-recoverable)
         +  error has occurred.  The object_id argument is the object
         +  where the error occurred, most often in response to a request
         +  to that object.  The code identifies the error and is defined
         +  by the object interface.  As such, each interface defines its
         +  own set of error codes.  The message is a brief description
         +  of the error, for (debugging) convenience.
         +/
        void function (void *data,
                       wl_display *wl_display,
                       void *object_id,
                       uint code,
                       const(char) *message) error;
        /++
         +  acknowledge object ID deletion
         +
         +  This event is used internally by the object ID management
         +  logic.  When a client deletes an object, the server will send
         +  this event to acknowledge that it has seen the delete request.
         +  When the client receives this event, it will know that it can
         +  safely reuse the object ID.
         +/
        void function (void *data,
                       wl_display *wl_display,
                       uint id) delete_id;
    }

    extern (D) int
    wl_display_add_listener(wl_display *wl_display,
                    const(wl_display_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_display,
                cast(Callback*)listener, data);
    }

    enum uint WL_DISPLAY_SYNC = 0;
    enum uint WL_DISPLAY_GET_REGISTRY = 1;

    extern (D) void
    wl_display_set_user_data(wl_display *wl_display, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_display, user_data);
    }

    extern (D) void *
    wl_display_get_user_data(wl_display *wl_display)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_display);
    }

    /++
     +  asynchronous roundtrip
     +
     +  The sync request asks the server to emit the 'done' event
     +  on the returned wl_callback object.  Since requests are
     +  handled in-order and events are delivered in-order, this can
     +  be used as a barrier to ensure all previous requests and the
     +  resulting events have been handled.
     +
     +  The object returned by this request will be destroyed by the
     +  compositor after the callback is fired and as such the client must not
     +  attempt to use it after that point.
     +
     +  The callback_data passed in the callback is the event serial.
     +/
    extern (D) wl_callback *
    wl_display_sync(wl_display *wl_display_)
    {
        wl_proxy *callback;

        callback = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_display_,
                WL_DISPLAY_SYNC, wl_callback_interface, null);

        return cast(wl_callback *) callback;
    }

    /++
     +  get global registry object
     +
     +  This request creates a registry object that allows the client
     +  to list and bind the global objects available from the
     +  compositor.
     +/
    extern (D) wl_registry *
    wl_display_get_registry(wl_display *wl_display_)
    {
        wl_proxy *registry;

        registry = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_display_,
                WL_DISPLAY_GET_REGISTRY, wl_registry_interface, null);

        return cast(wl_registry *) registry;
    }

    /++
     +  global registry object
     +
     +  The global registry object.  The server has a number of global
     +  objects that are available to all clients.  These objects
     +  typically represent an actual object in the server (for example,
     +  an input device) or they are singleton objects that provide
     +  extension functionality.
     +
     +  When a client creates a registry object, the registry object
     +  will emit a global event for each global currently in the
     +  registry.  Globals come and go as a result of device or
     +  monitor hotplugs, reconfiguration or other events, and the
     +  registry will send out global and global_remove events to
     +  keep the client up to date with the changes.  To mark the end
     +  of the initial burst of events, the client can use the
     +  wl_display.sync request immediately after calling
     +  wl_display.get_registry.
     +
     +  A client can bind to a global object by using the bind
     +  request.  This creates a client-side handle that lets the object
     +  emit events to the client and lets the client invoke requests on
     +  the object.
     +/
    struct wl_registry_listener
    {
        /++
         +  announce global object
         +
         +  Notify the client of global objects.
         +
         +          The event notifies the client that a global object with
         +          the given name is now available, and it implements the
         +          given version of the given interface.
         +/
        void function (void *data,
                       wl_registry *wl_registry,
                       uint name,
                       const(char) *iface,
                       uint ver) global;
        /++
         +  announce removal of global object
         +
         +  Notify the client of removed global objects.
         +
         +          This event notifies the client that the global identified
         +          by name is no longer available.  If the client bound to
         +          the global using the bind request, the client should now
         +          destroy that object.
         +
         +  The object remains valid and requests to the object will be
         +  ignored until the client destroys it, to avoid races between
         +  the global going away and a client sending a request to it.
         +/
        void function (void *data,
                       wl_registry *wl_registry,
                       uint name) global_remove;
    }

    extern (D) int
    wl_registry_add_listener(wl_registry *wl_registry,
                    const(wl_registry_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_registry,
                cast(Callback*)listener, data);
    }

    enum uint WL_REGISTRY_BIND = 0;

    extern (D) void
    wl_registry_set_user_data(wl_registry *wl_registry, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_registry, user_data);
    }

    extern (D) void *
    wl_registry_get_user_data(wl_registry *wl_registry)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_registry);
    }

    extern (D) void
    wl_registry_destroy(wl_registry *wl_registry)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_registry);
    }

    /++
     +  bind an object to the display
     +
     +  Binds a new, client-created object to the server using the
     +          specified name as the identifier.
     +/
    extern (D) void *
    wl_registry_bind(wl_registry *wl_registry_, uint name, const(wl_interface) *iface, uint ver)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_registry_,
                WL_REGISTRY_BIND, iface, name, iface.name, ver, null);

        return cast(void *) id;
    }

    /++
     +  callback object
     +
     +  Clients can handle the 'done' event to get notified when
     +  the related request is done.
     +/
    struct wl_callback_listener
    {
        /++
         +  done event
         +
         +  Notify the client when the related request is done.
         +/
        void function (void *data,
                       wl_callback *wl_callback,
                       uint callback_data) done;
    }

    extern (D) int
    wl_callback_add_listener(wl_callback *wl_callback,
                    const(wl_callback_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_callback,
                cast(Callback*)listener, data);
    }


    extern (D) void
    wl_callback_set_user_data(wl_callback *wl_callback, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_callback, user_data);
    }

    extern (D) void *
    wl_callback_get_user_data(wl_callback *wl_callback)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_callback);
    }

    extern (D) void
    wl_callback_destroy(wl_callback *wl_callback)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_callback);
    }

    enum uint WL_COMPOSITOR_CREATE_SURFACE = 0;
    enum uint WL_COMPOSITOR_CREATE_REGION = 1;

    extern (D) void
    wl_compositor_set_user_data(wl_compositor *wl_compositor, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_compositor, user_data);
    }

    extern (D) void *
    wl_compositor_get_user_data(wl_compositor *wl_compositor)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_compositor);
    }

    extern (D) void
    wl_compositor_destroy(wl_compositor *wl_compositor)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_compositor);
    }

    /++
     +  create new surface
     +
     +  Ask the compositor to create a new surface.
     +/
    extern (D) wl_surface *
    wl_compositor_create_surface(wl_compositor *wl_compositor_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_compositor_,
                WL_COMPOSITOR_CREATE_SURFACE, wl_surface_interface, null);

        return cast(wl_surface *) id;
    }

    /++
     +  create new region
     +
     +  Ask the compositor to create a new region.
     +/
    extern (D) wl_region *
    wl_compositor_create_region(wl_compositor *wl_compositor_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_compositor_,
                WL_COMPOSITOR_CREATE_REGION, wl_region_interface, null);

        return cast(wl_region *) id;
    }

    enum uint WL_SHM_POOL_CREATE_BUFFER = 0;
    enum uint WL_SHM_POOL_DESTROY = 1;
    enum uint WL_SHM_POOL_RESIZE = 2;

    extern (D) void
    wl_shm_pool_set_user_data(wl_shm_pool *wl_shm_pool, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_shm_pool, user_data);
    }

    extern (D) void *
    wl_shm_pool_get_user_data(wl_shm_pool *wl_shm_pool)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_shm_pool);
    }

    /++
     +  create a buffer from the pool
     +
     +  Create a wl_buffer object from the pool.
     +
     +  The buffer is created offset bytes into the pool and has
     +  width and height as specified.  The stride argument specifies
     +  the number of bytes from the beginning of one row to the beginning
     +  of the next.  The format is the pixel format of the buffer and
     +  must be one of those advertised through the wl_shm.format event.
     +
     +  A buffer will keep a reference to the pool it was created from
     +  so it is valid to destroy the pool immediately after creating
     +  a buffer from it.
     +/
    extern (D) wl_buffer *
    wl_shm_pool_create_buffer(wl_shm_pool *wl_shm_pool_, int offset, int width, int height, int stride, uint format)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_shm_pool_,
                WL_SHM_POOL_CREATE_BUFFER, wl_buffer_interface, null, offset, width, height, stride, format);

        return cast(wl_buffer *) id;
    }

    /++
     +  destroy the pool
     +
     +  Destroy the shared memory pool.
     +
     +  The mmapped memory will be released when all
     +  buffers that have been created from this pool
     +  are gone.
     +/
    extern (D) void
    wl_shm_pool_destroy(wl_shm_pool *wl_shm_pool_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shm_pool_,
                WL_SHM_POOL_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_shm_pool_);
    }

    /++
     +  change the size of the pool mapping
     +
     +  This request will cause the server to remap the backing memory
     +  for the pool from the file descriptor passed when the pool was
     +  created, but using the new size.  This request can only be
     +  used to make the pool bigger.
     +/
    extern (D) void
    wl_shm_pool_resize(wl_shm_pool *wl_shm_pool_, int size)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shm_pool_,
                WL_SHM_POOL_RESIZE, size);
    }

    /++
     +  wl_shm error values
     +
     +  These errors can be emitted in response to wl_shm requests.
     +/
    /++
     +  WL_SHM_ERROR_INVALID_FORMAT: buffer format is not known
     +  WL_SHM_ERROR_INVALID_STRIDE: invalid size or stride during pool or buffer creation
     +  WL_SHM_ERROR_INVALID_FD: mmapping the file descriptor failed
     +
     +/
    enum uint WL_SHM_ERROR_INVALID_FORMAT = 0;
    enum uint WL_SHM_ERROR_INVALID_STRIDE = 1; /// ditto
    enum uint WL_SHM_ERROR_INVALID_FD = 2; /// ditto

    /++
     +  pixel formats
     +
     +  This describes the memory layout of an individual pixel.
     +
     +  All renderers should support argb8888 and xrgb8888 but any other
     +  formats are optional and may not be supported by the particular
     +  renderer in use.
     +
     +  The drm format codes match the macros defined in drm_fourcc.h.
     +  The formats actually supported by the compositor will be
     +  reported by the format event.
     +/
    /++
     +  WL_SHM_FORMAT_ARGB8888: 32-bit ARGB format, [31:0] A:R:G:B 8:8:8:8 little endian
     +  WL_SHM_FORMAT_XRGB8888: 32-bit RGB format, [31:0] x:R:G:B 8:8:8:8 little endian
     +  WL_SHM_FORMAT_C8: 8-bit color index format, [7:0] C
     +  WL_SHM_FORMAT_RGB332: 8-bit RGB format, [7:0] R:G:B 3:3:2
     +  WL_SHM_FORMAT_BGR233: 8-bit BGR format, [7:0] B:G:R 2:3:3
     +  WL_SHM_FORMAT_XRGB4444: 16-bit xRGB format, [15:0] x:R:G:B 4:4:4:4 little endian
     +  WL_SHM_FORMAT_XBGR4444: 16-bit xBGR format, [15:0] x:B:G:R 4:4:4:4 little endian
     +  WL_SHM_FORMAT_RGBX4444: 16-bit RGBx format, [15:0] R:G:B:x 4:4:4:4 little endian
     +  WL_SHM_FORMAT_BGRX4444: 16-bit BGRx format, [15:0] B:G:R:x 4:4:4:4 little endian
     +  WL_SHM_FORMAT_ARGB4444: 16-bit ARGB format, [15:0] A:R:G:B 4:4:4:4 little endian
     +  WL_SHM_FORMAT_ABGR4444: 16-bit ABGR format, [15:0] A:B:G:R 4:4:4:4 little endian
     +  WL_SHM_FORMAT_RGBA4444: 16-bit RBGA format, [15:0] R:G:B:A 4:4:4:4 little endian
     +  WL_SHM_FORMAT_BGRA4444: 16-bit BGRA format, [15:0] B:G:R:A 4:4:4:4 little endian
     +  WL_SHM_FORMAT_XRGB1555: 16-bit xRGB format, [15:0] x:R:G:B 1:5:5:5 little endian
     +  WL_SHM_FORMAT_XBGR1555: 16-bit xBGR 1555 format, [15:0] x:B:G:R 1:5:5:5 little endian
     +  WL_SHM_FORMAT_RGBX5551: 16-bit RGBx 5551 format, [15:0] R:G:B:x 5:5:5:1 little endian
     +  WL_SHM_FORMAT_BGRX5551: 16-bit BGRx 5551 format, [15:0] B:G:R:x 5:5:5:1 little endian
     +  WL_SHM_FORMAT_ARGB1555: 16-bit ARGB 1555 format, [15:0] A:R:G:B 1:5:5:5 little endian
     +  WL_SHM_FORMAT_ABGR1555: 16-bit ABGR 1555 format, [15:0] A:B:G:R 1:5:5:5 little endian
     +  WL_SHM_FORMAT_RGBA5551: 16-bit RGBA 5551 format, [15:0] R:G:B:A 5:5:5:1 little endian
     +  WL_SHM_FORMAT_BGRA5551: 16-bit BGRA 5551 format, [15:0] B:G:R:A 5:5:5:1 little endian
     +  WL_SHM_FORMAT_RGB565: 16-bit RGB 565 format, [15:0] R:G:B 5:6:5 little endian
     +  WL_SHM_FORMAT_BGR565: 16-bit BGR 565 format, [15:0] B:G:R 5:6:5 little endian
     +  WL_SHM_FORMAT_RGB888: 24-bit RGB format, [23:0] R:G:B little endian
     +  WL_SHM_FORMAT_BGR888: 24-bit BGR format, [23:0] B:G:R little endian
     +  WL_SHM_FORMAT_XBGR8888: 32-bit xBGR format, [31:0] x:B:G:R 8:8:8:8 little endian
     +  WL_SHM_FORMAT_RGBX8888: 32-bit RGBx format, [31:0] R:G:B:x 8:8:8:8 little endian
     +  WL_SHM_FORMAT_BGRX8888: 32-bit BGRx format, [31:0] B:G:R:x 8:8:8:8 little endian
     +  WL_SHM_FORMAT_ABGR8888: 32-bit ABGR format, [31:0] A:B:G:R 8:8:8:8 little endian
     +  WL_SHM_FORMAT_RGBA8888: 32-bit RGBA format, [31:0] R:G:B:A 8:8:8:8 little endian
     +  WL_SHM_FORMAT_BGRA8888: 32-bit BGRA format, [31:0] B:G:R:A 8:8:8:8 little endian
     +  WL_SHM_FORMAT_XRGB2101010: 32-bit xRGB format, [31:0] x:R:G:B 2:10:10:10 little endian
     +  WL_SHM_FORMAT_XBGR2101010: 32-bit xBGR format, [31:0] x:B:G:R 2:10:10:10 little endian
     +  WL_SHM_FORMAT_RGBX1010102: 32-bit RGBx format, [31:0] R:G:B:x 10:10:10:2 little endian
     +  WL_SHM_FORMAT_BGRX1010102: 32-bit BGRx format, [31:0] B:G:R:x 10:10:10:2 little endian
     +  WL_SHM_FORMAT_ARGB2101010: 32-bit ARGB format, [31:0] A:R:G:B 2:10:10:10 little endian
     +  WL_SHM_FORMAT_ABGR2101010: 32-bit ABGR format, [31:0] A:B:G:R 2:10:10:10 little endian
     +  WL_SHM_FORMAT_RGBA1010102: 32-bit RGBA format, [31:0] R:G:B:A 10:10:10:2 little endian
     +  WL_SHM_FORMAT_BGRA1010102: 32-bit BGRA format, [31:0] B:G:R:A 10:10:10:2 little endian
     +  WL_SHM_FORMAT_YUYV: packed YCbCr format, [31:0] Cr0:Y1:Cb0:Y0 8:8:8:8 little endian
     +  WL_SHM_FORMAT_YVYU: packed YCbCr format, [31:0] Cb0:Y1:Cr0:Y0 8:8:8:8 little endian
     +  WL_SHM_FORMAT_UYVY: packed YCbCr format, [31:0] Y1:Cr0:Y0:Cb0 8:8:8:8 little endian
     +  WL_SHM_FORMAT_VYUY: packed YCbCr format, [31:0] Y1:Cb0:Y0:Cr0 8:8:8:8 little endian
     +  WL_SHM_FORMAT_AYUV: packed AYCbCr format, [31:0] A:Y:Cb:Cr 8:8:8:8 little endian
     +  WL_SHM_FORMAT_NV12: 2 plane YCbCr Cr:Cb format, 2x2 subsampled Cr:Cb plane
     +  WL_SHM_FORMAT_NV21: 2 plane YCbCr Cb:Cr format, 2x2 subsampled Cb:Cr plane
     +  WL_SHM_FORMAT_NV16: 2 plane YCbCr Cr:Cb format, 2x1 subsampled Cr:Cb plane
     +  WL_SHM_FORMAT_NV61: 2 plane YCbCr Cb:Cr format, 2x1 subsampled Cb:Cr plane
     +  WL_SHM_FORMAT_YUV410: 3 plane YCbCr format, 4x4 subsampled Cb (1) and Cr (2) planes
     +  WL_SHM_FORMAT_YVU410: 3 plane YCbCr format, 4x4 subsampled Cr (1) and Cb (2) planes
     +  WL_SHM_FORMAT_YUV411: 3 plane YCbCr format, 4x1 subsampled Cb (1) and Cr (2) planes
     +  WL_SHM_FORMAT_YVU411: 3 plane YCbCr format, 4x1 subsampled Cr (1) and Cb (2) planes
     +  WL_SHM_FORMAT_YUV420: 3 plane YCbCr format, 2x2 subsampled Cb (1) and Cr (2) planes
     +  WL_SHM_FORMAT_YVU420: 3 plane YCbCr format, 2x2 subsampled Cr (1) and Cb (2) planes
     +  WL_SHM_FORMAT_YUV422: 3 plane YCbCr format, 2x1 subsampled Cb (1) and Cr (2) planes
     +  WL_SHM_FORMAT_YVU422: 3 plane YCbCr format, 2x1 subsampled Cr (1) and Cb (2) planes
     +  WL_SHM_FORMAT_YUV444: 3 plane YCbCr format, non-subsampled Cb (1) and Cr (2) planes
     +  WL_SHM_FORMAT_YVU444: 3 plane YCbCr format, non-subsampled Cr (1) and Cb (2) planes
     +
     +/
    enum uint WL_SHM_FORMAT_ARGB8888 = 0;
    enum uint WL_SHM_FORMAT_XRGB8888 = 1; /// ditto
    enum uint WL_SHM_FORMAT_C8 = 0x20203843; /// ditto
    enum uint WL_SHM_FORMAT_RGB332 = 0x38424752; /// ditto
    enum uint WL_SHM_FORMAT_BGR233 = 0x38524742; /// ditto
    enum uint WL_SHM_FORMAT_XRGB4444 = 0x32315258; /// ditto
    enum uint WL_SHM_FORMAT_XBGR4444 = 0x32314258; /// ditto
    enum uint WL_SHM_FORMAT_RGBX4444 = 0x32315852; /// ditto
    enum uint WL_SHM_FORMAT_BGRX4444 = 0x32315842; /// ditto
    enum uint WL_SHM_FORMAT_ARGB4444 = 0x32315241; /// ditto
    enum uint WL_SHM_FORMAT_ABGR4444 = 0x32314241; /// ditto
    enum uint WL_SHM_FORMAT_RGBA4444 = 0x32314152; /// ditto
    enum uint WL_SHM_FORMAT_BGRA4444 = 0x32314142; /// ditto
    enum uint WL_SHM_FORMAT_XRGB1555 = 0x35315258; /// ditto
    enum uint WL_SHM_FORMAT_XBGR1555 = 0x35314258; /// ditto
    enum uint WL_SHM_FORMAT_RGBX5551 = 0x35315852; /// ditto
    enum uint WL_SHM_FORMAT_BGRX5551 = 0x35315842; /// ditto
    enum uint WL_SHM_FORMAT_ARGB1555 = 0x35315241; /// ditto
    enum uint WL_SHM_FORMAT_ABGR1555 = 0x35314241; /// ditto
    enum uint WL_SHM_FORMAT_RGBA5551 = 0x35314152; /// ditto
    enum uint WL_SHM_FORMAT_BGRA5551 = 0x35314142; /// ditto
    enum uint WL_SHM_FORMAT_RGB565 = 0x36314752; /// ditto
    enum uint WL_SHM_FORMAT_BGR565 = 0x36314742; /// ditto
    enum uint WL_SHM_FORMAT_RGB888 = 0x34324752; /// ditto
    enum uint WL_SHM_FORMAT_BGR888 = 0x34324742; /// ditto
    enum uint WL_SHM_FORMAT_XBGR8888 = 0x34324258; /// ditto
    enum uint WL_SHM_FORMAT_RGBX8888 = 0x34325852; /// ditto
    enum uint WL_SHM_FORMAT_BGRX8888 = 0x34325842; /// ditto
    enum uint WL_SHM_FORMAT_ABGR8888 = 0x34324241; /// ditto
    enum uint WL_SHM_FORMAT_RGBA8888 = 0x34324152; /// ditto
    enum uint WL_SHM_FORMAT_BGRA8888 = 0x34324142; /// ditto
    enum uint WL_SHM_FORMAT_XRGB2101010 = 0x30335258; /// ditto
    enum uint WL_SHM_FORMAT_XBGR2101010 = 0x30334258; /// ditto
    enum uint WL_SHM_FORMAT_RGBX1010102 = 0x30335852; /// ditto
    enum uint WL_SHM_FORMAT_BGRX1010102 = 0x30335842; /// ditto
    enum uint WL_SHM_FORMAT_ARGB2101010 = 0x30335241; /// ditto
    enum uint WL_SHM_FORMAT_ABGR2101010 = 0x30334241; /// ditto
    enum uint WL_SHM_FORMAT_RGBA1010102 = 0x30334152; /// ditto
    enum uint WL_SHM_FORMAT_BGRA1010102 = 0x30334142; /// ditto
    enum uint WL_SHM_FORMAT_YUYV = 0x56595559; /// ditto
    enum uint WL_SHM_FORMAT_YVYU = 0x55595659; /// ditto
    enum uint WL_SHM_FORMAT_UYVY = 0x59565955; /// ditto
    enum uint WL_SHM_FORMAT_VYUY = 0x59555956; /// ditto
    enum uint WL_SHM_FORMAT_AYUV = 0x56555941; /// ditto
    enum uint WL_SHM_FORMAT_NV12 = 0x3231564e; /// ditto
    enum uint WL_SHM_FORMAT_NV21 = 0x3132564e; /// ditto
    enum uint WL_SHM_FORMAT_NV16 = 0x3631564e; /// ditto
    enum uint WL_SHM_FORMAT_NV61 = 0x3136564e; /// ditto
    enum uint WL_SHM_FORMAT_YUV410 = 0x39565559; /// ditto
    enum uint WL_SHM_FORMAT_YVU410 = 0x39555659; /// ditto
    enum uint WL_SHM_FORMAT_YUV411 = 0x31315559; /// ditto
    enum uint WL_SHM_FORMAT_YVU411 = 0x31315659; /// ditto
    enum uint WL_SHM_FORMAT_YUV420 = 0x32315559; /// ditto
    enum uint WL_SHM_FORMAT_YVU420 = 0x32315659; /// ditto
    enum uint WL_SHM_FORMAT_YUV422 = 0x36315559; /// ditto
    enum uint WL_SHM_FORMAT_YVU422 = 0x36315659; /// ditto
    enum uint WL_SHM_FORMAT_YUV444 = 0x34325559; /// ditto
    enum uint WL_SHM_FORMAT_YVU444 = 0x34325659; /// ditto

    /++
     +  shared memory support
     +
     +  A global singleton object that provides support for shared
     +  memory.
     +
     +  Clients can create wl_shm_pool objects using the create_pool
     +  request.
     +
     +  At connection setup time, the wl_shm object emits one or more
     +  format events to inform clients about the valid pixel formats
     +  that can be used for buffers.
     +/
    struct wl_shm_listener
    {
        /++
         +  pixel format description
         +
         +  Informs the client about a valid pixel format that
         +  can be used for buffers. Known formats include
         +  argb8888 and xrgb8888.
         +/
        void function (void *data,
                       wl_shm *wl_shm,
                       uint format) format;
    }

    extern (D) int
    wl_shm_add_listener(wl_shm *wl_shm,
                    const(wl_shm_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_shm,
                cast(Callback*)listener, data);
    }

    enum uint WL_SHM_CREATE_POOL = 0;

    extern (D) void
    wl_shm_set_user_data(wl_shm *wl_shm, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_shm, user_data);
    }

    extern (D) void *
    wl_shm_get_user_data(wl_shm *wl_shm)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_shm);
    }

    extern (D) void
    wl_shm_destroy(wl_shm *wl_shm)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_shm);
    }

    /++
     +  create a shm pool
     +
     +  Create a new wl_shm_pool object.
     +
     +  The pool can be used to create shared memory based buffer
     +  objects.  The server will mmap size bytes of the passed file
     +          descriptor, to use as backing memory for the pool.
     +/
    extern (D) wl_shm_pool *
    wl_shm_create_pool(wl_shm *wl_shm_, int fd, int size)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_shm_,
                WL_SHM_CREATE_POOL, wl_shm_pool_interface, null, fd, size);

        return cast(wl_shm_pool *) id;
    }

    /++
     +  content for a wl_surface
     +
     +  A buffer provides the content for a wl_surface. Buffers are
     +  created through factory interfaces such as wl_drm, wl_shm or
     +  similar. It has a width and a height and can be attached to a
     +  wl_surface, but the mechanism by which a client provides and
     +  updates the contents is defined by the buffer factory interface.
     +/
    struct wl_buffer_listener
    {
        /++
         +  compositor releases buffer
         +
         +  Sent when this wl_buffer is no longer used by the compositor.
         +  The client is now free to reuse or destroy this buffer and its
         +  backing storage.
         +
         +  If a client receives a release event before the frame callback
         +  requested in the same wl_surface.commit that attaches this
         +  wl_buffer to a surface, then the client is immediately free to
         +  reuse the buffer and its backing storage, and does not need a
         +  second buffer for the next surface content update. Typically
         +  this is possible, when the compositor maintains a copy of the
         +  wl_surface contents, e.g. as a GL texture. This is an important
         +  optimization for GL(ES) compositors with wl_shm clients.
         +/
        void function (void *data,
                       wl_buffer *wl_buffer) release;
    }

    extern (D) int
    wl_buffer_add_listener(wl_buffer *wl_buffer,
                    const(wl_buffer_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_buffer,
                cast(Callback*)listener, data);
    }

    enum uint WL_BUFFER_DESTROY = 0;

    extern (D) void
    wl_buffer_set_user_data(wl_buffer *wl_buffer, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_buffer, user_data);
    }

    extern (D) void *
    wl_buffer_get_user_data(wl_buffer *wl_buffer)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_buffer);
    }

    /++
     +  destroy a buffer
     +
     +  Destroy a buffer. If and how you need to release the backing
     +  storage is defined by the buffer factory interface.
     +
     +  For possible side-effects to a surface, see wl_surface.attach.
     +/
    extern (D) void
    wl_buffer_destroy(wl_buffer *wl_buffer_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_buffer_,
                WL_BUFFER_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_buffer_);
    }

    /++
     +  WL_DATA_OFFER_ERROR_INVALID_FINISH: finish request was called untimely
     +  WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK: action mask contains invalid values
     +  WL_DATA_OFFER_ERROR_INVALID_ACTION: action argument has an invalid value
     +  WL_DATA_OFFER_ERROR_INVALID_OFFER: offer doesn't accept this request
     +
     +/
    enum uint WL_DATA_OFFER_ERROR_INVALID_FINISH = 0;
    enum uint WL_DATA_OFFER_ERROR_INVALID_ACTION_MASK = 1; /// ditto
    enum uint WL_DATA_OFFER_ERROR_INVALID_ACTION = 2; /// ditto
    enum uint WL_DATA_OFFER_ERROR_INVALID_OFFER = 3; /// ditto

    /++
     +  offer to transfer data
     +
     +  A wl_data_offer represents a piece of data offered for transfer
     +  by another client (the source client).  It is used by the
     +  copy-and-paste and drag-and-drop mechanisms.  The offer
     +  describes the different mime types that the data can be
     +  converted to and provides the mechanism for transferring the
     +  data directly from the source client.
     +/
    struct wl_data_offer_listener
    {
        /++
         +  advertise offered mime type
         +
         +  Sent immediately after creating the wl_data_offer object.  One
         +  event per offered mime type.
         +/
        void function (void *data,
                       wl_data_offer *wl_data_offer,
                       const(char) *mime_type) offer;
        /++
         +  notify the source-side available actions
         +
         +  This event indicates the actions offered by the data source. It
         +  will be sent right after wl_data_device.enter, or anytime the source
         +  side changes its offered actions through wl_data_source.set_actions.
         +/
        void function (void *data,
                       wl_data_offer *wl_data_offer,
                       uint source_actions) source_actions;
        /++
         +  notify the selected action
         +
         +  This event indicates the action selected by the compositor after
         +  matching the source/destination side actions. Only one action (or
         +  none) will be offered here.
         +
         +  This event can be emitted multiple times during the drag-and-drop
         +  operation in response to destination side action changes through
         +  wl_data_offer.set_actions.
         +
         +  This event will no longer be emitted after wl_data_device.drop
         +  happened on the drag-and-drop destination, the client must
         +  honor the last action received, or the last preferred one set
         +  through wl_data_offer.set_actions when handling an "ask" action.
         +
         +  Compositors may also change the selected action on the fly, mainly
         +  in response to keyboard modifier changes during the drag-and-drop
         +  operation.
         +
         +  The most recent action received is always the valid one. Prior to
         +  receiving wl_data_device.drop, the chosen action may change (e.g.
         +  due to keyboard modifiers being pressed). At the time of receiving
         +  wl_data_device.drop the drag-and-drop destination must honor the
         +  last action received.
         +
         +  Action changes may still happen after wl_data_device.drop,
         +  especially on "ask" actions, where the drag-and-drop destination
         +  may choose another action afterwards. Action changes happening
         +  at this stage are always the result of inter-client negotiation, the
         +  compositor shall no longer be able to induce a different action.
         +
         +  Upon "ask" actions, it is expected that the drag-and-drop destination
         +  may potentially choose a different action and/or mime type,
         +  based on wl_data_offer.source_actions and finally chosen by the
         +  user (e.g. popping up a menu with the available options). The
         +  final wl_data_offer.set_actions and wl_data_offer.accept requests
         +  must happen before the call to wl_data_offer.finish.
         +/
        void function (void *data,
                       wl_data_offer *wl_data_offer,
                       uint dnd_action) action;
    }

    extern (D) int
    wl_data_offer_add_listener(wl_data_offer *wl_data_offer,
                    const(wl_data_offer_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_data_offer,
                cast(Callback*)listener, data);
    }

    enum uint WL_DATA_OFFER_ACCEPT = 0;
    enum uint WL_DATA_OFFER_RECEIVE = 1;
    enum uint WL_DATA_OFFER_DESTROY = 2;
    enum uint WL_DATA_OFFER_FINISH = 3;
    enum uint WL_DATA_OFFER_SET_ACTIONS = 4;

    extern (D) void
    wl_data_offer_set_user_data(wl_data_offer *wl_data_offer, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_data_offer, user_data);
    }

    extern (D) void *
    wl_data_offer_get_user_data(wl_data_offer *wl_data_offer)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_data_offer);
    }

    /++
     +  accept one of the offered mime types
     +
     +  Indicate that the client can accept the given mime type, or
     +  NULL for not accepted.
     +
     +  For objects of version 2 or older, this request is used by the
     +  client to give feedback whether the client can receive the given
     +  mime type, or NULL if none is accepted; the feedback does not
     +  determine whether the drag-and-drop operation succeeds or not.
     +
     +  For objects of version 3 or newer, this request determines the
     +  final result of the drag-and-drop operation. If the end result
     +  is that no mime types were accepted, the drag-and-drop operation
     +  will be cancelled and the corresponding drag source will receive
     +  wl_data_source.cancelled. Clients may still use this event in
     +  conjunction with wl_data_source.action for feedback.
     +/
    extern (D) void
    wl_data_offer_accept(wl_data_offer *wl_data_offer_, uint serial, const(char) *mime_type)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_offer_,
                WL_DATA_OFFER_ACCEPT, serial, mime_type);
    }

    /++
     +  request that the data is transferred
     +
     +  To transfer the offered data, the client issues this request
     +  and indicates the mime type it wants to receive.  The transfer
     +  happens through the passed file descriptor (typically created
     +  with the pipe system call).  The source client writes the data
     +  in the mime type representation requested and then closes the
     +  file descriptor.
     +
     +  The receiving client reads from the read end of the pipe until
     +  EOF and then closes its end, at which point the transfer is
     +  complete.
     +
     +  This request may happen multiple times for different mime types,
     +  both before and after wl_data_device.drop. Drag-and-drop destination
     +  clients may preemptively fetch data or examine it more closely to
     +  determine acceptance.
     +/
    extern (D) void
    wl_data_offer_receive(wl_data_offer *wl_data_offer_, const(char) *mime_type, int fd)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_offer_,
                WL_DATA_OFFER_RECEIVE, mime_type, fd);
    }

    /++
     +  destroy data offer
     +
     +  Destroy the data offer.
     +/
    extern (D) void
    wl_data_offer_destroy(wl_data_offer *wl_data_offer_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_offer_,
                WL_DATA_OFFER_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_data_offer_);
    }

    /++
     +  the offer will no longer be used
     +
     +  Notifies the compositor that the drag destination successfully
     +  finished the drag-and-drop operation.
     +
     +  Upon receiving this request, the compositor will emit
     +  wl_data_source.dnd_finished on the drag source client.
     +
     +  It is a client error to perform other requests than
     +  wl_data_offer.destroy after this one. It is also an error to perform
     +  this request after a NULL mime type has been set in
     +  wl_data_offer.accept or no action was received through
     +  wl_data_offer.action.
     +/
    extern (D) void
    wl_data_offer_finish(wl_data_offer *wl_data_offer_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_offer_,
                WL_DATA_OFFER_FINISH);
    }

    /++
     +  set the available/preferred drag-and-drop actions
     +
     +  Sets the actions that the destination side client supports for
     +  this operation. This request may trigger the emission of
     +  wl_data_source.action and wl_data_offer.action events if the compositor
     +  needs to change the selected action.
     +
     +  This request can be called multiple times throughout the
     +  drag-and-drop operation, typically in response to wl_data_device.enter
     +  or wl_data_device.motion events.
     +
     +  This request determines the final result of the drag-and-drop
     +  operation. If the end result is that no action is accepted,
     +  the drag source will receive wl_drag_source.cancelled.
     +
     +  The dnd_actions argument must contain only values expressed in the
     +  wl_data_device_manager.dnd_actions enum, and the preferred_action
     +  argument must only contain one of those values set, otherwise it
     +  will result in a protocol error.
     +
     +  While managing an "ask" action, the destination drag-and-drop client
     +  may perform further wl_data_offer.receive requests, and is expected
     +  to perform one last wl_data_offer.set_actions request with a preferred
     +  action other than "ask" (and optionally wl_data_offer.accept) before
     +  requesting wl_data_offer.finish, in order to convey the action selected
     +  by the user. If the preferred action is not in the
     +  wl_data_offer.source_actions mask, an error will be raised.
     +
     +  If the "ask" action is dismissed (e.g. user cancellation), the client
     +  is expected to perform wl_data_offer.destroy right away.
     +
     +  This request can only be made on drag-and-drop offers, a protocol error
     +  will be raised otherwise.
     +/
    extern (D) void
    wl_data_offer_set_actions(wl_data_offer *wl_data_offer_, uint dnd_actions, uint preferred_action)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_offer_,
                WL_DATA_OFFER_SET_ACTIONS, dnd_actions, preferred_action);
    }

    /++
     +  WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK: action mask contains invalid values
     +  WL_DATA_SOURCE_ERROR_INVALID_SOURCE: source doesn't accept this request
     +
     +/
    enum uint WL_DATA_SOURCE_ERROR_INVALID_ACTION_MASK = 0;
    enum uint WL_DATA_SOURCE_ERROR_INVALID_SOURCE = 1; /// ditto

    /++
     +  offer to transfer data
     +
     +  The wl_data_source object is the source side of a wl_data_offer.
     +  It is created by the source client in a data transfer and
     +  provides a way to describe the offered data and a way to respond
     +  to requests to transfer the data.
     +/
    struct wl_data_source_listener
    {
        /++
         +  a target accepts an offered mime type
         +
         +  Sent when a target accepts pointer_focus or motion events.  If
         +  a target does not accept any of the offered types, type is NULL.
         +
         +  Used for feedback during drag-and-drop.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source,
                       const(char) *mime_type) target;
        /++
         +  send the data
         +
         +  Request for data from the client.  Send the data as the
         +  specified mime type over the passed file descriptor, then
         +  close it.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source,
                       const(char) *mime_type,
                       int fd) send;
        /++
         +  selection was cancelled
         +
         +  This data source is no longer valid. There are several reasons why
         +  this could happen:
         +
         +  - The data source has been replaced by another data source.
         +  - The drag-and-drop operation was performed, but the drop destination
         +    did not accept any of the mime types offered through
         +    wl_data_source.target.
         +  - The drag-and-drop operation was performed, but the drop destination
         +    did not select any of the actions present in the mask offered through
         +    wl_data_source.action.
         +  - The drag-and-drop operation was performed but didn't happen over a
         +    surface.
         +  - The compositor cancelled the drag-and-drop operation (e.g. compositor
         +    dependent timeouts to avoid stale drag-and-drop transfers).
         +
         +  The client should clean up and destroy this data source.
         +
         +  For objects of version 2 or older, wl_data_source.cancelled will
         +  only be emitted if the data source was replaced by another data
         +  source.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source) cancelled;
        /++
         +  the drag-and-drop operation physically finished
         +
         +  The user performed the drop action. This event does not indicate
         +  acceptance, wl_data_source.cancelled may still be emitted afterwards
         +  if the drop destination does not accept any mime type.
         +
         +  However, this event might however not be received if the compositor
         +  cancelled the drag-and-drop operation before this event could happen.
         +
         +  Note that the data_source may still be used in the future and should
         +  not be destroyed here.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source) dnd_drop_performed;
        /++
         +  the drag-and-drop operation concluded
         +
         +  The drop destination finished interoperating with this data
         +  source, so the client is now free to destroy this data source and
         +  free all associated data.
         +
         +  If the action used to perform the operation was "move", the
         +  source can now delete the transferred data.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source) dnd_finished;
        /++
         +  notify the selected action
         +
         +  This event indicates the action selected by the compositor after
         +  matching the source/destination side actions. Only one action (or
         +  none) will be offered here.
         +
         +  This event can be emitted multiple times during the drag-and-drop
         +  operation, mainly in response to destination side changes through
         +  wl_data_offer.set_actions, and as the data device enters/leaves
         +  surfaces.
         +
         +  It is only possible to receive this event after
         +  wl_data_source.dnd_drop_performed if the drag-and-drop operation
         +  ended in an "ask" action, in which case the final wl_data_source.action
         +  event will happen immediately before wl_data_source.dnd_finished.
         +
         +  Compositors may also change the selected action on the fly, mainly
         +  in response to keyboard modifier changes during the drag-and-drop
         +  operation.
         +
         +  The most recent action received is always the valid one. The chosen
         +  action may change alongside negotiation (e.g. an "ask" action can turn
         +  into a "move" operation), so the effects of the final action must
         +  always be applied in wl_data_offer.dnd_finished.
         +
         +  Clients can trigger cursor surface changes from this point, so
         +  they reflect the current action.
         +/
        void function (void *data,
                       wl_data_source *wl_data_source,
                       uint dnd_action) action;
    }

    extern (D) int
    wl_data_source_add_listener(wl_data_source *wl_data_source,
                    const(wl_data_source_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_data_source,
                cast(Callback*)listener, data);
    }

    enum uint WL_DATA_SOURCE_OFFER = 0;
    enum uint WL_DATA_SOURCE_DESTROY = 1;
    enum uint WL_DATA_SOURCE_SET_ACTIONS = 2;

    extern (D) void
    wl_data_source_set_user_data(wl_data_source *wl_data_source, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_data_source, user_data);
    }

    extern (D) void *
    wl_data_source_get_user_data(wl_data_source *wl_data_source)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_data_source);
    }

    /++
     +  add an offered mime type
     +
     +  This request adds a mime type to the set of mime types
     +  advertised to targets.  Can be called several times to offer
     +  multiple types.
     +/
    extern (D) void
    wl_data_source_offer(wl_data_source *wl_data_source_, const(char) *mime_type)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_source_,
                WL_DATA_SOURCE_OFFER, mime_type);
    }

    /++
     +  destroy the data source
     +
     +  Destroy the data source.
     +/
    extern (D) void
    wl_data_source_destroy(wl_data_source *wl_data_source_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_source_,
                WL_DATA_SOURCE_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_data_source_);
    }

    /++
     +  set the available drag-and-drop actions
     +
     +  Sets the actions that the source side client supports for this
     +  operation. This request may trigger wl_data_source.action and
     +  wl_data_offer.action events if the compositor needs to change the
     +  selected action.
     +
     +  The dnd_actions argument must contain only values expressed in the
     +  wl_data_device_manager.dnd_actions enum, otherwise it will result
     +  in a protocol error.
     +
     +  This request must be made once only, and can only be made on sources
     +  used in drag-and-drop, so it must be performed before
     +  wl_data_device.start_drag. Attempting to use the source other than
     +  for drag-and-drop will raise a protocol error.
     +/
    extern (D) void
    wl_data_source_set_actions(wl_data_source *wl_data_source_, uint dnd_actions)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_source_,
                WL_DATA_SOURCE_SET_ACTIONS, dnd_actions);
    }

    /++
     +  WL_DATA_DEVICE_ERROR_ROLE: given wl_surface has another role
     +
     +/
    enum uint WL_DATA_DEVICE_ERROR_ROLE = 0;

    /++
     +  data transfer device
     +
     +  There is one wl_data_device per seat which can be obtained
     +  from the global wl_data_device_manager singleton.
     +
     +  A wl_data_device provides access to inter-client data transfer
     +  mechanisms such as copy-and-paste and drag-and-drop.
     +/
    struct wl_data_device_listener
    {
        /++
         +  introduce a new wl_data_offer
         +
         +  The data_offer event introduces a new wl_data_offer object,
         +  which will subsequently be used in either the
         +  data_device.enter event (for drag-and-drop) or the
         +  data_device.selection event (for selections).  Immediately
         +  following the data_device_data_offer event, the new data_offer
         +  object will send out data_offer.offer events to describe the
         +  mime types it offers.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device,
                       wl_data_offer *id) data_offer;
        /++
         +  initiate drag-and-drop session
         +
         +  This event is sent when an active drag-and-drop pointer enters
         +  a surface owned by the client.  The position of the pointer at
         +  enter time is provided by the x and y arguments, in surface-local
         +  coordinates.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device,
                       uint serial,
                       wl_surface *surface,
                       wl_fixed_t x,
                       wl_fixed_t y,
                       wl_data_offer *id) enter;
        /++
         +  end drag-and-drop session
         +
         +  This event is sent when the drag-and-drop pointer leaves the
         +  surface and the session ends.  The client must destroy the
         +  wl_data_offer introduced at enter time at this point.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device) leave;
        /++
         +  drag-and-drop session motion
         +
         +  This event is sent when the drag-and-drop pointer moves within
         +  the currently focused surface. The new position of the pointer
         +  is provided by the x and y arguments, in surface-local
         +  coordinates.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device,
                       uint time,
                       wl_fixed_t x,
                       wl_fixed_t y) motion;
        /++
         +  end drag-and-drop session successfully
         +
         +  The event is sent when a drag-and-drop operation is ended
         +  because the implicit grab is removed.
         +
         +  The drag-and-drop destination is expected to honor the last action
         +  received through wl_data_offer.action, if the resulting action is
         +  "copy" or "move", the destination can still perform
         +  wl_data_offer.receive requests, and is expected to end all
         +  transfers with a wl_data_offer.finish request.
         +
         +  If the resulting action is "ask", the action will not be considered
         +  final. The drag-and-drop destination is expected to perform one last
         +  wl_data_offer.set_actions request, or wl_data_offer.destroy in order
         +  to cancel the operation.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device) drop;
        /++
         +  advertise new selection
         +
         +  The selection event is sent out to notify the client of a new
         +  wl_data_offer for the selection for this device.  The
         +  data_device.data_offer and the data_offer.offer events are
         +  sent out immediately before this event to introduce the data
         +  offer object.  The selection event is sent to a client
         +  immediately before receiving keyboard focus and when a new
         +  selection is set while the client has keyboard focus.  The
         +  data_offer is valid until a new data_offer or NULL is received
         +  or until the client loses keyboard focus.  The client must
         +  destroy the previous selection data_offer, if any, upon receiving
         +  this event.
         +/
        void function (void *data,
                       wl_data_device *wl_data_device,
                       wl_data_offer *id) selection;
    }

    extern (D) int
    wl_data_device_add_listener(wl_data_device *wl_data_device,
                    const(wl_data_device_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_data_device,
                cast(Callback*)listener, data);
    }

    enum uint WL_DATA_DEVICE_START_DRAG = 0;
    enum uint WL_DATA_DEVICE_SET_SELECTION = 1;
    enum uint WL_DATA_DEVICE_RELEASE = 2;

    extern (D) void
    wl_data_device_set_user_data(wl_data_device *wl_data_device, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_data_device, user_data);
    }

    extern (D) void *
    wl_data_device_get_user_data(wl_data_device *wl_data_device)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_data_device);
    }

    extern (D) void
    wl_data_device_destroy(wl_data_device *wl_data_device)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_data_device);
    }

    /++
     +  start drag-and-drop operation
     +
     +  This request asks the compositor to start a drag-and-drop
     +  operation on behalf of the client.
     +
     +  The source argument is the data source that provides the data
     +  for the eventual data transfer. If source is NULL, enter, leave
     +  and motion events are sent only to the client that initiated the
     +  drag and the client is expected to handle the data passing
     +  internally.
     +
     +  The origin surface is the surface where the drag originates and
     +  the client must have an active implicit grab that matches the
     +  serial.
     +
     +  The icon surface is an optional (can be NULL) surface that
     +  provides an icon to be moved around with the cursor.  Initially,
     +  the top-left corner of the icon surface is placed at the cursor
     +  hotspot, but subsequent wl_surface.attach request can move the
     +  relative position. Attach requests must be confirmed with
     +  wl_surface.commit as usual. The icon surface is given the role of
     +  a drag-and-drop icon. If the icon surface already has another role,
     +  it raises a protocol error.
     +
     +  The current and pending input regions of the icon wl_surface are
     +  cleared, and wl_surface.set_input_region is ignored until the
     +  wl_surface is no longer used as the icon surface. When the use
     +  as an icon ends, the current and pending input regions become
     +  undefined, and the wl_surface is unmapped.
     +/
    extern (D) void
    wl_data_device_start_drag(wl_data_device *wl_data_device_, wl_data_source *source, wl_surface *origin, wl_surface *icon, uint serial)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_device_,
                WL_DATA_DEVICE_START_DRAG, source, origin, icon, serial);
    }

    /++
     +  copy data to the selection
     +
     +  This request asks the compositor to set the selection
     +  to the data from the source on behalf of the client.
     +
     +  To unset the selection, set the source to NULL.
     +/
    extern (D) void
    wl_data_device_set_selection(wl_data_device *wl_data_device_, wl_data_source *source, uint serial)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_device_,
                WL_DATA_DEVICE_SET_SELECTION, source, serial);
    }

    /++
     +  destroy data device
     +
     +  This request destroys the data device.
     +/
    extern (D) void
    wl_data_device_release(wl_data_device *wl_data_device_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_data_device_,
                WL_DATA_DEVICE_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_data_device_);
    }

    /++
     +  drag and drop actions
     +
     +  This is a bitmask of the available/preferred actions in a
     +  drag-and-drop operation.
     +
     +  In the compositor, the selected action is a result of matching the
     +  actions offered by the source and destination sides.  "action" events
     +  with a "none" action will be sent to both source and destination if
     +  there is no match. All further checks will effectively happen on
     +  (source actions ∩ destination actions).
     +
     +  In addition, compositors may also pick different actions in
     +  reaction to key modifiers being pressed. One common design that
     +  is used in major toolkits (and the behavior recommended for
     +  compositors) is:
     +
     +  - If no modifiers are pressed, the first match (in bit order)
     +    will be used.
     +  - Pressing Shift selects "move", if enabled in the mask.
     +  - Pressing Control selects "copy", if enabled in the mask.
     +
     +  Behavior beyond that is considered implementation-dependent.
     +  Compositors may for example bind other modifiers (like Alt/Meta)
     +  or drags initiated with other buttons than BTN_LEFT to specific
     +  actions (e.g. "ask").
     +/
    /++
     +  WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE: no action
     +  WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY: copy action
     +  WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE: move action
     +  WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK: ask action
     +
     +/
    enum uint WL_DATA_DEVICE_MANAGER_DND_ACTION_NONE = 0;
    enum uint WL_DATA_DEVICE_MANAGER_DND_ACTION_COPY = 1; /// ditto
    enum uint WL_DATA_DEVICE_MANAGER_DND_ACTION_MOVE = 2; /// ditto
    enum uint WL_DATA_DEVICE_MANAGER_DND_ACTION_ASK = 4; /// ditto

    enum uint WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE = 0;
    enum uint WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE = 1;

    extern (D) void
    wl_data_device_manager_set_user_data(wl_data_device_manager *wl_data_device_manager, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_data_device_manager, user_data);
    }

    extern (D) void *
    wl_data_device_manager_get_user_data(wl_data_device_manager *wl_data_device_manager)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_data_device_manager);
    }

    extern (D) void
    wl_data_device_manager_destroy(wl_data_device_manager *wl_data_device_manager)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_data_device_manager);
    }

    /++
     +  create a new data source
     +
     +  Create a new data source.
     +/
    extern (D) wl_data_source *
    wl_data_device_manager_create_data_source(wl_data_device_manager *wl_data_device_manager_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_data_device_manager_,
                WL_DATA_DEVICE_MANAGER_CREATE_DATA_SOURCE, wl_data_source_interface, null);

        return cast(wl_data_source *) id;
    }

    /++
     +  create a new data device
     +
     +  Create a new data device for a given seat.
     +/
    extern (D) wl_data_device *
    wl_data_device_manager_get_data_device(wl_data_device_manager *wl_data_device_manager_, wl_seat *seat)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_data_device_manager_,
                WL_DATA_DEVICE_MANAGER_GET_DATA_DEVICE, wl_data_device_interface, null, seat);

        return cast(wl_data_device *) id;
    }

    /++
     +  WL_SHELL_ERROR_ROLE: given wl_surface has another role
     +
     +/
    enum uint WL_SHELL_ERROR_ROLE = 0;

    enum uint WL_SHELL_GET_SHELL_SURFACE = 0;

    extern (D) void
    wl_shell_set_user_data(wl_shell *wl_shell, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_shell, user_data);
    }

    extern (D) void *
    wl_shell_get_user_data(wl_shell *wl_shell)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_shell);
    }

    extern (D) void
    wl_shell_destroy(wl_shell *wl_shell)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_shell);
    }

    /++
     +  create a shell surface from a surface
     +
     +  Create a shell surface for an existing surface. This gives
     +  the wl_surface the role of a shell surface. If the wl_surface
     +  already has another role, it raises a protocol error.
     +
     +  Only one shell surface can be associated with a given surface.
     +/
    extern (D) wl_shell_surface *
    wl_shell_get_shell_surface(wl_shell *wl_shell_, wl_surface *surface)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_shell_,
                WL_SHELL_GET_SHELL_SURFACE, wl_shell_surface_interface, null, surface);

        return cast(wl_shell_surface *) id;
    }

    /++
     +  edge values for resizing
     +
     +  These values are used to indicate which edge of a surface
     +  is being dragged in a resize operation. The server may
     +  use this information to adapt its behavior, e.g. choose
     +  an appropriate cursor image.
     +/
    /++
     +  WL_SHELL_SURFACE_RESIZE_NONE: no edge
     +  WL_SHELL_SURFACE_RESIZE_TOP: top edge
     +  WL_SHELL_SURFACE_RESIZE_BOTTOM: bottom edge
     +  WL_SHELL_SURFACE_RESIZE_LEFT: left edge
     +  WL_SHELL_SURFACE_RESIZE_TOP_LEFT: top and left edges
     +  WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT: bottom and left edges
     +  WL_SHELL_SURFACE_RESIZE_RIGHT: right edge
     +  WL_SHELL_SURFACE_RESIZE_TOP_RIGHT: top and right edges
     +  WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT: bottom and right edges
     +
     +/
    enum uint WL_SHELL_SURFACE_RESIZE_NONE = 0;
    enum uint WL_SHELL_SURFACE_RESIZE_TOP = 1; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_BOTTOM = 2; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_LEFT = 4; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_TOP_LEFT = 5; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_BOTTOM_LEFT = 6; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_RIGHT = 8; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_TOP_RIGHT = 9; /// ditto
    enum uint WL_SHELL_SURFACE_RESIZE_BOTTOM_RIGHT = 10; /// ditto

    /++
     +  details of transient behaviour
     +
     +  These flags specify details of the expected behaviour
     +  of transient surfaces. Used in the set_transient request.
     +/
    /++
     +  WL_SHELL_SURFACE_TRANSIENT_INACTIVE: do not set keyboard focus
     +
     +/
    enum uint WL_SHELL_SURFACE_TRANSIENT_INACTIVE = 0x1;

    /++
     +  different method to set the surface fullscreen
     +
     +  Hints to indicate to the compositor how to deal with a conflict
     +  between the dimensions of the surface and the dimensions of the
     +  output. The compositor is free to ignore this parameter.
     +/
    /++
     +  WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT: no preference, apply default policy
     +  WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE: scale, preserve the surface's aspect ratio and center on output
     +  WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER: switch output mode to the smallest mode that can fit the surface, add black borders to compensate size mismatch
     +  WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL: no upscaling, center on output and add black borders to compensate size mismatch
     +
     +/
    enum uint WL_SHELL_SURFACE_FULLSCREEN_METHOD_DEFAULT = 0;
    enum uint WL_SHELL_SURFACE_FULLSCREEN_METHOD_SCALE = 1; /// ditto
    enum uint WL_SHELL_SURFACE_FULLSCREEN_METHOD_DRIVER = 2; /// ditto
    enum uint WL_SHELL_SURFACE_FULLSCREEN_METHOD_FILL = 3; /// ditto

    /++
     +  desktop-style metadata interface
     +
     +  An interface that may be implemented by a wl_surface, for
     +  implementations that provide a desktop-style user interface.
     +
     +  It provides requests to treat surfaces like toplevel, fullscreen
     +  or popup windows, move, resize or maximize them, associate
     +  metadata like title and class, etc.
     +
     +  On the server side the object is automatically destroyed when
     +  the related wl_surface is destroyed. On the client side,
     +  wl_shell_surface_destroy() must be called before destroying
     +  the wl_surface object.
     +/
    struct wl_shell_surface_listener
    {
        /++
         +  ping client
         +
         +  Ping a client to check if it is receiving events and sending
         +  requests. A client is expected to reply with a pong request.
         +/
        void function (void *data,
                       wl_shell_surface *wl_shell_surface,
                       uint serial) ping;
        /++
         +  suggest resize
         +
         +  The configure event asks the client to resize its surface.
         +
         +  The size is a hint, in the sense that the client is free to
         +  ignore it if it doesn't resize, pick a smaller size (to
         +  satisfy aspect ratio or resize in steps of NxM pixels).
         +
         +  The edges parameter provides a hint about how the surface
         +  was resized. The client may use this information to decide
         +  how to adjust its content to the new size (e.g. a scrolling
         +  area might adjust its content position to leave the viewable
         +  content unmoved).
         +
         +  The client is free to dismiss all but the last configure
         +  event it received.
         +
         +  The width and height arguments specify the size of the window
         +  in surface-local coordinates.
         +/
        void function (void *data,
                       wl_shell_surface *wl_shell_surface,
                       uint edges,
                       int width,
                       int height) configure;
        /++
         +  popup interaction is done
         +
         +  The popup_done event is sent out when a popup grab is broken,
         +  that is, when the user clicks a surface that doesn't belong
         +  to the client owning the popup surface.
         +/
        void function (void *data,
                       wl_shell_surface *wl_shell_surface) popup_done;
    }

    extern (D) int
    wl_shell_surface_add_listener(wl_shell_surface *wl_shell_surface,
                    const(wl_shell_surface_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_shell_surface,
                cast(Callback*)listener, data);
    }

    enum uint WL_SHELL_SURFACE_PONG = 0;
    enum uint WL_SHELL_SURFACE_MOVE = 1;
    enum uint WL_SHELL_SURFACE_RESIZE = 2;
    enum uint WL_SHELL_SURFACE_SET_TOPLEVEL = 3;
    enum uint WL_SHELL_SURFACE_SET_TRANSIENT = 4;
    enum uint WL_SHELL_SURFACE_SET_FULLSCREEN = 5;
    enum uint WL_SHELL_SURFACE_SET_POPUP = 6;
    enum uint WL_SHELL_SURFACE_SET_MAXIMIZED = 7;
    enum uint WL_SHELL_SURFACE_SET_TITLE = 8;
    enum uint WL_SHELL_SURFACE_SET_CLASS = 9;

    extern (D) void
    wl_shell_surface_set_user_data(wl_shell_surface *wl_shell_surface, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_shell_surface, user_data);
    }

    extern (D) void *
    wl_shell_surface_get_user_data(wl_shell_surface *wl_shell_surface)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_shell_surface);
    }

    extern (D) void
    wl_shell_surface_destroy(wl_shell_surface *wl_shell_surface)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_shell_surface);
    }

    /++
     +  respond to a ping event
     +
     +  A client must respond to a ping event with a pong request or
     +  the client may be deemed unresponsive.
     +/
    extern (D) void
    wl_shell_surface_pong(wl_shell_surface *wl_shell_surface_, uint serial)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_PONG, serial);
    }

    /++
     +  start an interactive move
     +
     +  Start a pointer-driven move of the surface.
     +
     +  This request must be used in response to a button press event.
     +  The server may ignore move requests depending on the state of
     +  the surface (e.g. fullscreen or maximized).
     +/
    extern (D) void
    wl_shell_surface_move(wl_shell_surface *wl_shell_surface_, wl_seat *seat, uint serial)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_MOVE, seat, serial);
    }

    /++
     +  start an interactive resize
     +
     +  Start a pointer-driven resizing of the surface.
     +
     +  This request must be used in response to a button press event.
     +  The server may ignore resize requests depending on the state of
     +  the surface (e.g. fullscreen or maximized).
     +/
    extern (D) void
    wl_shell_surface_resize(wl_shell_surface *wl_shell_surface_, wl_seat *seat, uint serial, uint edges)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_RESIZE, seat, serial, edges);
    }

    /++
     +  make the surface a toplevel surface
     +
     +  Map the surface as a toplevel surface.
     +
     +  A toplevel surface is not fullscreen, maximized or transient.
     +/
    extern (D) void
    wl_shell_surface_set_toplevel(wl_shell_surface *wl_shell_surface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_TOPLEVEL);
    }

    /++
     +  make the surface a transient surface
     +
     +  Map the surface relative to an existing surface.
     +
     +  The x and y arguments specify the location of the upper left
     +  corner of the surface relative to the upper left corner of the
     +  parent surface, in surface-local coordinates.
     +
     +  The flags argument controls details of the transient behaviour.
     +/
    extern (D) void
    wl_shell_surface_set_transient(wl_shell_surface *wl_shell_surface_, wl_surface *parent, int x, int y, uint flags)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_TRANSIENT, parent, x, y, flags);
    }

    /++
     +  make the surface a fullscreen surface
     +
     +  Map the surface as a fullscreen surface.
     +
     +  If an output parameter is given then the surface will be made
     +  fullscreen on that output. If the client does not specify the
     +  output then the compositor will apply its policy - usually
     +  choosing the output on which the surface has the biggest surface
     +  area.
     +
     +  The client may specify a method to resolve a size conflict
     +  between the output size and the surface size - this is provided
     +  through the method parameter.
     +
     +  The framerate parameter is used only when the method is set
     +  to "driver", to indicate the preferred framerate. A value of 0
     +  indicates that the client does not care about framerate.  The
     +  framerate is specified in mHz, that is framerate of 60000 is 60Hz.
     +
     +  A method of "scale" or "driver" implies a scaling operation of
     +  the surface, either via a direct scaling operation or a change of
     +  the output mode. This will override any kind of output scaling, so
     +  that mapping a surface with a buffer size equal to the mode can
     +  fill the screen independent of buffer_scale.
     +
     +  A method of "fill" means we don't scale up the buffer, however
     +  any output scale is applied. This means that you may run into
     +  an edge case where the application maps a buffer with the same
     +  size of the output mode but buffer_scale 1 (thus making a
     +  surface larger than the output). In this case it is allowed to
     +  downscale the results to fit the screen.
     +
     +  The compositor must reply to this request with a configure event
     +  with the dimensions for the output on which the surface will
     +  be made fullscreen.
     +/
    extern (D) void
    wl_shell_surface_set_fullscreen(wl_shell_surface *wl_shell_surface_, uint method, uint framerate, wl_output *output)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_FULLSCREEN, method, framerate, output);
    }

    /++
     +  make the surface a popup surface
     +
     +  Map the surface as a popup.
     +
     +  A popup surface is a transient surface with an added pointer
     +  grab.
     +
     +  An existing implicit grab will be changed to owner-events mode,
     +  and the popup grab will continue after the implicit grab ends
     +  (i.e. releasing the mouse button does not cause the popup to
     +  be unmapped).
     +
     +  The popup grab continues until the window is destroyed or a
     +  mouse button is pressed in any other client's window. A click
     +  in any of the client's surfaces is reported as normal, however,
     +  clicks in other clients' surfaces will be discarded and trigger
     +  the callback.
     +
     +  The x and y arguments specify the location of the upper left
     +  corner of the surface relative to the upper left corner of the
     +  parent surface, in surface-local coordinates.
     +/
    extern (D) void
    wl_shell_surface_set_popup(wl_shell_surface *wl_shell_surface_, wl_seat *seat, uint serial, wl_surface *parent, int x, int y, uint flags)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_POPUP, seat, serial, parent, x, y, flags);
    }

    /++
     +  make the surface a maximized surface
     +
     +  Map the surface as a maximized surface.
     +
     +  If an output parameter is given then the surface will be
     +  maximized on that output. If the client does not specify the
     +  output then the compositor will apply its policy - usually
     +  choosing the output on which the surface has the biggest surface
     +  area.
     +
     +  The compositor will reply with a configure event telling
     +  the expected new surface size. The operation is completed
     +  on the next buffer attach to this surface.
     +
     +  A maximized surface typically fills the entire output it is
     +  bound to, except for desktop elements such as panels. This is
     +  the main difference between a maximized shell surface and a
     +  fullscreen shell surface.
     +
     +  The details depend on the compositor implementation.
     +/
    extern (D) void
    wl_shell_surface_set_maximized(wl_shell_surface *wl_shell_surface_, wl_output *output)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_MAXIMIZED, output);
    }

    /++
     +  set surface title
     +
     +  Set a short title for the surface.
     +
     +  This string may be used to identify the surface in a task bar,
     +  window list, or other user interface elements provided by the
     +  compositor.
     +
     +  The string must be encoded in UTF-8.
     +/
    extern (D) void
    wl_shell_surface_set_title(wl_shell_surface *wl_shell_surface_, const(char) *title)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_TITLE, title);
    }

    /++
     +  set surface class
     +
     +  Set a class for the surface.
     +
     +  The surface class identifies the general class of applications
     +  to which the surface belongs. A common convention is to use the
     +  file name (or the full path if it is a non-standard location) of
     +  the application's .desktop file as the class.
     +/
    extern (D) void
    wl_shell_surface_set_class(wl_shell_surface *wl_shell_surface_, const(char) *class_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_shell_surface_,
                WL_SHELL_SURFACE_SET_CLASS, class_);
    }

    /++
     +  wl_surface error values
     +
     +  These errors can be emitted in response to wl_surface requests.
     +/
    /++
     +  WL_SURFACE_ERROR_INVALID_SCALE: buffer scale value is invalid
     +  WL_SURFACE_ERROR_INVALID_TRANSFORM: buffer transform value is invalid
     +
     +/
    enum uint WL_SURFACE_ERROR_INVALID_SCALE = 0;
    enum uint WL_SURFACE_ERROR_INVALID_TRANSFORM = 1; /// ditto

    /++
     +  an onscreen surface
     +
     +  A surface is a rectangular area that is displayed on the screen.
     +  It has a location, size and pixel contents.
     +
     +  The size of a surface (and relative positions on it) is described
     +  in surface-local coordinates, which may differ from the buffer
     +  coordinates of the pixel content, in case a buffer_transform
     +  or a buffer_scale is used.
     +
     +  A surface without a "role" is fairly useless: a compositor does
     +  not know where, when or how to present it. The role is the
     +  purpose of a wl_surface. Examples of roles are a cursor for a
     +  pointer (as set by wl_pointer.set_cursor), a drag icon
     +  (wl_data_device.start_drag), a sub-surface
     +  (wl_subcompositor.get_subsurface), and a window as defined by a
     +  shell protocol (e.g. wl_shell.get_shell_surface).
     +
     +  A surface can have only one role at a time. Initially a
     +  wl_surface does not have a role. Once a wl_surface is given a
     +  role, it is set permanently for the whole lifetime of the
     +  wl_surface object. Giving the current role again is allowed,
     +  unless explicitly forbidden by the relevant interface
     +  specification.
     +
     +  Surface roles are given by requests in other interfaces such as
     +  wl_pointer.set_cursor. The request should explicitly mention
     +  that this request gives a role to a wl_surface. Often, this
     +  request also creates a new protocol object that represents the
     +  role and adds additional functionality to wl_surface. When a
     +  client wants to destroy a wl_surface, they must destroy this 'role
     +  object' before the wl_surface.
     +
     +  Destroying the role object does not remove the role from the
     +  wl_surface, but it may stop the wl_surface from "playing the role".
     +  For instance, if a wl_subsurface object is destroyed, the wl_surface
     +  it was created for will be unmapped and forget its position and
     +  z-order. It is allowed to create a wl_subsurface for the same
     +  wl_surface again, but it is not allowed to use the wl_surface as
     +  a cursor (cursor is a different role than sub-surface, and role
     +  switching is not allowed).
     +/
    struct wl_surface_listener
    {
        /++
         +  surface enters an output
         +
         +  This is emitted whenever a surface's creation, movement, or resizing
         +  results in some part of it being within the scanout region of an
         +  output.
         +
         +  Note that a surface may be overlapping with zero or more outputs.
         +/
        void function (void *data,
                       wl_surface *wl_surface,
                       wl_output *output) enter;
        /++
         +  surface leaves an output
         +
         +  This is emitted whenever a surface's creation, movement, or resizing
         +  results in it no longer having any part of it within the scanout region
         +  of an output.
         +/
        void function (void *data,
                       wl_surface *wl_surface,
                       wl_output *output) leave;
    }

    extern (D) int
    wl_surface_add_listener(wl_surface *wl_surface,
                    const(wl_surface_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_surface,
                cast(Callback*)listener, data);
    }

    enum uint WL_SURFACE_DESTROY = 0;
    enum uint WL_SURFACE_ATTACH = 1;
    enum uint WL_SURFACE_DAMAGE = 2;
    enum uint WL_SURFACE_FRAME = 3;
    enum uint WL_SURFACE_SET_OPAQUE_REGION = 4;
    enum uint WL_SURFACE_SET_INPUT_REGION = 5;
    enum uint WL_SURFACE_COMMIT = 6;
    enum uint WL_SURFACE_SET_BUFFER_TRANSFORM = 7;
    enum uint WL_SURFACE_SET_BUFFER_SCALE = 8;
    enum uint WL_SURFACE_DAMAGE_BUFFER = 9;

    extern (D) void
    wl_surface_set_user_data(wl_surface *wl_surface, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_surface, user_data);
    }

    extern (D) void *
    wl_surface_get_user_data(wl_surface *wl_surface)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_surface);
    }

    /++
     +  delete surface
     +
     +  Deletes the surface and invalidates its object ID.
     +/
    extern (D) void
    wl_surface_destroy(wl_surface *wl_surface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_surface_);
    }

    /++
     +  set the surface contents
     +
     +  Set a buffer as the content of this surface.
     +
     +  The new size of the surface is calculated based on the buffer
     +  size transformed by the inverse buffer_transform and the
     +  inverse buffer_scale. This means that the supplied buffer
     +  must be an integer multiple of the buffer_scale.
     +
     +  The x and y arguments specify the location of the new pending
     +  buffer's upper left corner, relative to the current buffer's upper
     +  left corner, in surface-local coordinates. In other words, the
     +  x and y, combined with the new surface size define in which
     +  directions the surface's size changes.
     +
     +  Surface contents are double-buffered state, see wl_surface.commit.
     +
     +  The initial surface contents are void; there is no content.
     +  wl_surface.attach assigns the given wl_buffer as the pending
     +  wl_buffer. wl_surface.commit makes the pending wl_buffer the new
     +  surface contents, and the size of the surface becomes the size
     +  calculated from the wl_buffer, as described above. After commit,
     +  there is no pending buffer until the next attach.
     +
     +  Committing a pending wl_buffer allows the compositor to read the
     +  pixels in the wl_buffer. The compositor may access the pixels at
     +  any time after the wl_surface.commit request. When the compositor
     +  will not access the pixels anymore, it will send the
     +  wl_buffer.release event. Only after receiving wl_buffer.release,
     +  the client may reuse the wl_buffer. A wl_buffer that has been
     +  attached and then replaced by another attach instead of committed
     +  will not receive a release event, and is not used by the
     +  compositor.
     +
     +  Destroying the wl_buffer after wl_buffer.release does not change
     +  the surface contents. However, if the client destroys the
     +  wl_buffer before receiving the wl_buffer.release event, the surface
     +  contents become undefined immediately.
     +
     +  If wl_surface.attach is sent with a NULL wl_buffer, the
     +  following wl_surface.commit will remove the surface content.
     +/
    extern (D) void
    wl_surface_attach(wl_surface *wl_surface_, wl_buffer *buffer, int x, int y)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_ATTACH, buffer, x, y);
    }

    /++
     +  mark part of the surface damaged
     +
     +  This request is used to describe the regions where the pending
     +  buffer is different from the current surface contents, and where
     +  the surface therefore needs to be repainted. The compositor
     +  ignores the parts of the damage that fall outside of the surface.
     +
     +  Damage is double-buffered state, see wl_surface.commit.
     +
     +  The damage rectangle is specified in surface-local coordinates,
     +  where x and y specify the upper left corner of the damage rectangle.
     +
     +  The initial value for pending damage is empty: no damage.
     +  wl_surface.damage adds pending damage: the new pending damage
     +  is the union of old pending damage and the given rectangle.
     +
     +  wl_surface.commit assigns pending damage as the current damage,
     +  and clears pending damage. The server will clear the current
     +  damage as it repaints the surface.
     +
     +  Alternatively, damage can be posted with wl_surface.damage_buffer
     +  which uses buffer coordinates instead of surface coordinates,
     +  and is probably the preferred and intuitive way of doing this.
     +/
    extern (D) void
    wl_surface_damage(wl_surface *wl_surface_, int x, int y, int width, int height)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_DAMAGE, x, y, width, height);
    }

    /++
     +  request a frame throttling hint
     +
     +  Request a notification when it is a good time to start drawing a new
     +  frame, by creating a frame callback. This is useful for throttling
     +  redrawing operations, and driving animations.
     +
     +  When a client is animating on a wl_surface, it can use the 'frame'
     +  request to get notified when it is a good time to draw and commit the
     +  next frame of animation. If the client commits an update earlier than
     +  that, it is likely that some updates will not make it to the display,
     +  and the client is wasting resources by drawing too often.
     +
     +  The frame request will take effect on the next wl_surface.commit.
     +  The notification will only be posted for one frame unless
     +  requested again. For a wl_surface, the notifications are posted in
     +  the order the frame requests were committed.
     +
     +  The server must send the notifications so that a client
     +  will not send excessive updates, while still allowing
     +  the highest possible update rate for clients that wait for the reply
     +  before drawing again. The server should give some time for the client
     +  to draw and commit after sending the frame callback events to let it
     +  hit the next output refresh.
     +
     +  A server should avoid signaling the frame callbacks if the
     +  surface is not visible in any way, e.g. the surface is off-screen,
     +  or completely obscured by other opaque surfaces.
     +
     +  The object returned by this request will be destroyed by the
     +  compositor after the callback is fired and as such the client must not
     +  attempt to use it after that point.
     +
     +  The callback_data passed in the callback is the current time, in
     +  milliseconds, with an undefined base.
     +/
    extern (D) wl_callback *
    wl_surface_frame(wl_surface *wl_surface_)
    {
        wl_proxy *callback;

        callback = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_surface_,
                WL_SURFACE_FRAME, wl_callback_interface, null);

        return cast(wl_callback *) callback;
    }

    /++
     +  set opaque region
     +
     +  This request sets the region of the surface that contains
     +  opaque content.
     +
     +  The opaque region is an optimization hint for the compositor
     +  that lets it optimize the redrawing of content behind opaque
     +  regions.  Setting an opaque region is not required for correct
     +  behaviour, but marking transparent content as opaque will result
     +  in repaint artifacts.
     +
     +  The opaque region is specified in surface-local coordinates.
     +
     +  The compositor ignores the parts of the opaque region that fall
     +  outside of the surface.
     +
     +  Opaque region is double-buffered state, see wl_surface.commit.
     +
     +  wl_surface.set_opaque_region changes the pending opaque region.
     +  wl_surface.commit copies the pending region to the current region.
     +  Otherwise, the pending and current regions are never changed.
     +
     +  The initial value for an opaque region is empty. Setting the pending
     +  opaque region has copy semantics, and the wl_region object can be
     +  destroyed immediately. A NULL wl_region causes the pending opaque
     +  region to be set to empty.
     +/
    extern (D) void
    wl_surface_set_opaque_region(wl_surface *wl_surface_, wl_region *region)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_SET_OPAQUE_REGION, region);
    }

    /++
     +  set input region
     +
     +  This request sets the region of the surface that can receive
     +  pointer and touch events.
     +
     +  Input events happening outside of this region will try the next
     +  surface in the server surface stack. The compositor ignores the
     +  parts of the input region that fall outside of the surface.
     +
     +  The input region is specified in surface-local coordinates.
     +
     +  Input region is double-buffered state, see wl_surface.commit.
     +
     +  wl_surface.set_input_region changes the pending input region.
     +  wl_surface.commit copies the pending region to the current region.
     +  Otherwise the pending and current regions are never changed,
     +  except cursor and icon surfaces are special cases, see
     +  wl_pointer.set_cursor and wl_data_device.start_drag.
     +
     +  The initial value for an input region is infinite. That means the
     +  whole surface will accept input. Setting the pending input region
     +  has copy semantics, and the wl_region object can be destroyed
     +  immediately. A NULL wl_region causes the input region to be set
     +  to infinite.
     +/
    extern (D) void
    wl_surface_set_input_region(wl_surface *wl_surface_, wl_region *region)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_SET_INPUT_REGION, region);
    }

    /++
     +  commit pending surface state
     +
     +  Surface state (input, opaque, and damage regions, attached buffers,
     +  etc.) is double-buffered. Protocol requests modify the pending state,
     +  as opposed to the current state in use by the compositor. A commit
     +  request atomically applies all pending state, replacing the current
     +  state. After commit, the new pending state is as documented for each
     +  related request.
     +
     +  On commit, a pending wl_buffer is applied first, and all other state
     +  second. This means that all coordinates in double-buffered state are
     +  relative to the new wl_buffer coming into use, except for
     +  wl_surface.attach itself. If there is no pending wl_buffer, the
     +  coordinates are relative to the current surface contents.
     +
     +  All requests that need a commit to become effective are documented
     +  to affect double-buffered state.
     +
     +  Other interfaces may add further double-buffered surface state.
     +/
    extern (D) void
    wl_surface_commit(wl_surface *wl_surface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_COMMIT);
    }

    /++
     +  sets the buffer transformation
     +
     +  This request sets an optional transformation on how the compositor
     +  interprets the contents of the buffer attached to the surface. The
     +  accepted values for the transform parameter are the values for
     +  wl_output.transform.
     +
     +  Buffer transform is double-buffered state, see wl_surface.commit.
     +
     +  A newly created surface has its buffer transformation set to normal.
     +
     +  wl_surface.set_buffer_transform changes the pending buffer
     +  transformation. wl_surface.commit copies the pending buffer
     +  transformation to the current one. Otherwise, the pending and current
     +  values are never changed.
     +
     +  The purpose of this request is to allow clients to render content
     +  according to the output transform, thus permitting the compositor to
     +  use certain optimizations even if the display is rotated. Using
     +  hardware overlays and scanning out a client buffer for fullscreen
     +  surfaces are examples of such optimizations. Those optimizations are
     +  highly dependent on the compositor implementation, so the use of this
     +  request should be considered on a case-by-case basis.
     +
     +  Note that if the transform value includes 90 or 270 degree rotation,
     +  the width of the buffer will become the surface height and the height
     +  of the buffer will become the surface width.
     +
     +  If transform is not one of the values from the
     +  wl_output.transform enum the invalid_transform protocol error
     +  is raised.
     +/
    extern (D) void
    wl_surface_set_buffer_transform(wl_surface *wl_surface_, int transform)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_SET_BUFFER_TRANSFORM, transform);
    }

    /++
     +  sets the buffer scaling factor
     +
     +  This request sets an optional scaling factor on how the compositor
     +  interprets the contents of the buffer attached to the window.
     +
     +  Buffer scale is double-buffered state, see wl_surface.commit.
     +
     +  A newly created surface has its buffer scale set to 1.
     +
     +  wl_surface.set_buffer_scale changes the pending buffer scale.
     +  wl_surface.commit copies the pending buffer scale to the current one.
     +  Otherwise, the pending and current values are never changed.
     +
     +  The purpose of this request is to allow clients to supply higher
     +  resolution buffer data for use on high resolution outputs. It is
     +  intended that you pick the same buffer scale as the scale of the
     +  output that the surface is displayed on. This means the compositor
     +  can avoid scaling when rendering the surface on that output.
     +
     +  Note that if the scale is larger than 1, then you have to attach
     +  a buffer that is larger (by a factor of scale in each dimension)
     +  than the desired surface size.
     +
     +  If scale is not positive the invalid_scale protocol error is
     +  raised.
     +/
    extern (D) void
    wl_surface_set_buffer_scale(wl_surface *wl_surface_, int scale)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_SET_BUFFER_SCALE, scale);
    }

    /++
     +  mark part of the surface damaged using buffer coordinates
     +
     +  This request is used to describe the regions where the pending
     +  buffer is different from the current surface contents, and where
     +  the surface therefore needs to be repainted. The compositor
     +  ignores the parts of the damage that fall outside of the surface.
     +
     +  Damage is double-buffered state, see wl_surface.commit.
     +
     +  The damage rectangle is specified in buffer coordinates,
     +  where x and y specify the upper left corner of the damage rectangle.
     +
     +  The initial value for pending damage is empty: no damage.
     +  wl_surface.damage_buffer adds pending damage: the new pending
     +  damage is the union of old pending damage and the given rectangle.
     +
     +  wl_surface.commit assigns pending damage as the current damage,
     +  and clears pending damage. The server will clear the current
     +  damage as it repaints the surface.
     +
     +  This request differs from wl_surface.damage in only one way - it
     +  takes damage in buffer coordinates instead of surface-local
     +  coordinates. While this generally is more intuitive than surface
     +  coordinates, it is especially desirable when using wp_viewport
     +  or when a drawing library (like EGL) is unaware of buffer scale
     +  and buffer transform.
     +
     +  Note: Because buffer transformation changes and damage requests may
     +  be interleaved in the protocol stream, it is impossible to determine
     +  the actual mapping between surface and buffer damage until
     +  wl_surface.commit time. Therefore, compositors wishing to take both
     +  kinds of damage into account will have to accumulate damage from the
     +  two requests separately and only transform from one to the other
     +  after receiving the wl_surface.commit.
     +/
    extern (D) void
    wl_surface_damage_buffer(wl_surface *wl_surface_, int x, int y, int width, int height)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_surface_,
                WL_SURFACE_DAMAGE_BUFFER, x, y, width, height);
    }

    /++
     +  seat capability bitmask
     +
     +  This is a bitmask of capabilities this seat has; if a member is
     +  set, then it is present on the seat.
     +/
    /++
     +  WL_SEAT_CAPABILITY_POINTER: the seat has pointer devices
     +  WL_SEAT_CAPABILITY_KEYBOARD: the seat has one or more keyboards
     +  WL_SEAT_CAPABILITY_TOUCH: the seat has touch devices
     +
     +/
    enum uint WL_SEAT_CAPABILITY_POINTER = 1;
    enum uint WL_SEAT_CAPABILITY_KEYBOARD = 2; /// ditto
    enum uint WL_SEAT_CAPABILITY_TOUCH = 4; /// ditto

    /++
     +  group of input devices
     +
     +  A seat is a group of keyboards, pointer and touch devices. This
     +  object is published as a global during start up, or when such a
     +  device is hot plugged.  A seat typically has a pointer and
     +  maintains a keyboard focus and a pointer focus.
     +/
    struct wl_seat_listener
    {
        /++
         +  seat capabilities changed
         +
         +  This is emitted whenever a seat gains or loses the pointer,
         +  keyboard or touch capabilities.  The argument is a capability
         +  enum containing the complete set of capabilities this seat has.
         +
         +  When the pointer capability is added, a client may create a
         +  wl_pointer object using the wl_seat.get_pointer request. This object
         +  will receive pointer events until the capability is removed in the
         +  future.
         +
         +  When the pointer capability is removed, a client should destroy the
         +  wl_pointer objects associated with the seat where the capability was
         +  removed, using the wl_pointer.release request. No further pointer
         +  events will be received on these objects.
         +
         +  In some compositors, if a seat regains the pointer capability and a
         +  client has a previously obtained wl_pointer object of version 4 or
         +  less, that object may start sending pointer events again. This
         +  behavior is considered a misinterpretation of the intended behavior
         +  and must not be relied upon by the client. wl_pointer objects of
         +  version 5 or later must not send events if created before the most
         +  recent event notifying the client of an added pointer capability.
         +
         +  The above behavior also applies to wl_keyboard and wl_touch with the
         +  keyboard and touch capabilities, respectively.
         +/
        void function (void *data,
                       wl_seat *wl_seat,
                       uint capabilities) capabilities;
        /++
         +  unique identifier for this seat
         +
         +  In a multiseat configuration this can be used by the client to help
         +  identify which physical devices the seat represents. Based on
         +  the seat configuration used by the compositor.
         +/
        void function (void *data,
                       wl_seat *wl_seat,
                       const(char) *name) name;
    }

    extern (D) int
    wl_seat_add_listener(wl_seat *wl_seat,
                    const(wl_seat_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_seat,
                cast(Callback*)listener, data);
    }

    enum uint WL_SEAT_GET_POINTER = 0;
    enum uint WL_SEAT_GET_KEYBOARD = 1;
    enum uint WL_SEAT_GET_TOUCH = 2;
    enum uint WL_SEAT_RELEASE = 3;

    extern (D) void
    wl_seat_set_user_data(wl_seat *wl_seat, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_seat, user_data);
    }

    extern (D) void *
    wl_seat_get_user_data(wl_seat *wl_seat)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_seat);
    }

    extern (D) void
    wl_seat_destroy(wl_seat *wl_seat)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_seat);
    }

    /++
     +  return pointer object
     +
     +  The ID provided will be initialized to the wl_pointer interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the pointer
     +  capability, or has had the pointer capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the pointer capability.
     +/
    extern (D) wl_pointer *
    wl_seat_get_pointer(wl_seat *wl_seat_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_seat_,
                WL_SEAT_GET_POINTER, wl_pointer_interface, null);

        return cast(wl_pointer *) id;
    }

    /++
     +  return keyboard object
     +
     +  The ID provided will be initialized to the wl_keyboard interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the keyboard
     +  capability, or has had the keyboard capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the keyboard capability.
     +/
    extern (D) wl_keyboard *
    wl_seat_get_keyboard(wl_seat *wl_seat_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_seat_,
                WL_SEAT_GET_KEYBOARD, wl_keyboard_interface, null);

        return cast(wl_keyboard *) id;
    }

    /++
     +  return touch object
     +
     +  The ID provided will be initialized to the wl_touch interface
     +  for this seat.
     +
     +  This request only takes effect if the seat has the touch
     +  capability, or has had the touch capability in the past.
     +  It is a protocol violation to issue this request on a seat that has
     +  never had the touch capability.
     +/
    extern (D) wl_touch *
    wl_seat_get_touch(wl_seat *wl_seat_)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_seat_,
                WL_SEAT_GET_TOUCH, wl_touch_interface, null);

        return cast(wl_touch *) id;
    }

    /++
     +  release the seat object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the seat object anymore.
     +/
    extern (D) void
    wl_seat_release(wl_seat *wl_seat_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_seat_,
                WL_SEAT_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_seat_);
    }

    /++
     +  WL_POINTER_ERROR_ROLE: given wl_surface has another role
     +
     +/
    enum uint WL_POINTER_ERROR_ROLE = 0;

    /++
     +  physical button state
     +
     +  Describes the physical state of a button that produced the button
     +  	event.
     +/
    /++
     +  WL_POINTER_BUTTON_STATE_RELEASED: the button is not pressed
     +  WL_POINTER_BUTTON_STATE_PRESSED: the button is pressed
     +
     +/
    enum uint WL_POINTER_BUTTON_STATE_RELEASED = 0;
    enum uint WL_POINTER_BUTTON_STATE_PRESSED = 1; /// ditto

    /++
     +  axis types
     +
     +  Describes the axis types of scroll events.
     +/
    /++
     +  WL_POINTER_AXIS_VERTICAL_SCROLL: vertical axis
     +  WL_POINTER_AXIS_HORIZONTAL_SCROLL: horizontal axis
     +
     +/
    enum uint WL_POINTER_AXIS_VERTICAL_SCROLL = 0;
    enum uint WL_POINTER_AXIS_HORIZONTAL_SCROLL = 1; /// ditto

    /++
     +  axis source types
     +
     +  Describes the source types for axis events. This indicates to the
     +  client how an axis event was physically generated; a client may
     +  adjust the user interface accordingly. For example, scroll events
     +  from a "finger" source may be in a smooth coordinate space with
     +  kinetic scrolling whereas a "wheel" source may be in discrete steps
     +  of a number of lines.
     +
     +  The "continuous" axis source is a device generating events in a
     +  continuous coordinate space, but using something other than a
     +  finger. One example for this source is button-based scrolling where
     +  the vertical motion of a device is converted to scroll events while
     +  a button is held down.
     +/
    /++
     +  WL_POINTER_AXIS_SOURCE_WHEEL: a physical wheel
     +  WL_POINTER_AXIS_SOURCE_FINGER: finger on a touch surface
     +  WL_POINTER_AXIS_SOURCE_CONTINUOUS: continuous coordinate space
     +
     +/
    enum uint WL_POINTER_AXIS_SOURCE_WHEEL = 0;
    enum uint WL_POINTER_AXIS_SOURCE_FINGER = 1; /// ditto
    enum uint WL_POINTER_AXIS_SOURCE_CONTINUOUS = 2; /// ditto

    /++
     +  pointer input device
     +
     +  The wl_pointer interface represents one or more input devices,
     +  such as mice, which control the pointer location and pointer_focus
     +  of a seat.
     +
     +  The wl_pointer interface generates motion, enter and leave
     +  events for the surfaces that the pointer is located over,
     +  and button and axis events for button presses, button releases
     +  and scrolling.
     +/
    struct wl_pointer_listener
    {
        /++
         +  enter event
         +
         +  Notification that this seat's pointer is focused on a certain
         +  surface.
         +
         +  When a seat's focus enters a surface, the pointer image
         +  is undefined and a client should respond to this event by setting
         +  an appropriate pointer image with the set_cursor request.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint serial,
                       wl_surface *surface,
                       wl_fixed_t surface_x,
                       wl_fixed_t surface_y) enter;
        /++
         +  leave event
         +
         +  Notification that this seat's pointer is no longer focused on
         +  a certain surface.
         +
         +  The leave notification is sent before the enter notification
         +  for the new focus.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint serial,
                       wl_surface *surface) leave;
        /++
         +  pointer motion event
         +
         +  Notification of pointer location change. The arguments
         +  surface_x and surface_y are the location relative to the
         +  focused surface.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint time,
                       wl_fixed_t surface_x,
                       wl_fixed_t surface_y) motion;
        /++
         +  pointer button event
         +
         +  Mouse button click and release notifications.
         +
         +  The location of the click is given by the last motion or
         +  enter event.
         +          The time argument is a timestamp with millisecond
         +          granularity, with an undefined base.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint serial,
                       uint time,
                       uint button,
                       uint state) button;
        /++
         +  axis event
         +
         +  Scroll and other axis notifications.
         +
         +  For scroll events (vertical and horizontal scroll axes), the
         +  value parameter is the length of a vector along the specified
         +  axis in a coordinate space identical to those of motion events,
         +  representing a relative movement along the specified axis.
         +
         +  For devices that support movements non-parallel to axes multiple
         +  axis events will be emitted.
         +
         +  When applicable, for example for touch pads, the server can
         +  choose to emit scroll events where the motion vector is
         +  equivalent to a motion event vector.
         +
         +  When applicable, a client can transform its content relative to the
         +  scroll distance.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint time,
                       uint axis,
                       wl_fixed_t value) axis;
        /++
         +  end of a pointer event sequence
         +
         +  Indicates the end of a set of events that logically belong together.
         +  A client is expected to accumulate the data in all events within the
         +  frame before proceeding.
         +
         +  All wl_pointer events before a wl_pointer.frame event belong
         +  logically together. For example, in a diagonal scroll motion the
         +  compositor will send an optional wl_pointer.axis_source event, two
         +  wl_pointer.axis events (horizontal and vertical) and finally a
         +  wl_pointer.frame event. The client may use this information to
         +  calculate a diagonal vector for scrolling.
         +
         +  When multiple wl_pointer.axis events occur within the same frame,
         +  the motion vector is the combined motion of all events.
         +  When a wl_pointer.axis and a wl_pointer.axis_stop event occur within
         +  the same frame, this indicates that axis movement in one axis has
         +  stopped but continues in the other axis.
         +  When multiple wl_pointer.axis_stop events occur within the same
         +  frame, this indicates that these axes stopped in the same instance.
         +
         +  A wl_pointer.frame event is sent for every logical event group,
         +  even if the group only contains a single wl_pointer event.
         +  Specifically, a client may get a sequence: motion, frame, button,
         +  frame, axis, frame, axis_stop, frame.
         +
         +  The wl_pointer.enter and wl_pointer.leave events are logical events
         +  generated by the compositor and not the hardware. These events are
         +  also grouped by a wl_pointer.frame. When a pointer moves from one
         +  surface to another, a compositor should group the
         +  wl_pointer.leave event within the same wl_pointer.frame.
         +  However, a client must not rely on wl_pointer.leave and
         +  wl_pointer.enter being in the same wl_pointer.frame.
         +  Compositor-specific policies may require the wl_pointer.leave and
         +  wl_pointer.enter event being split across multiple wl_pointer.frame
         +  groups.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer) frame;
        /++
         +  axis source event
         +
         +  Source information for scroll and other axes.
         +
         +  This event does not occur on its own. It is sent before a
         +  wl_pointer.frame event and carries the source information for
         +  all events within that frame.
         +
         +  The source specifies how this event was generated. If the source is
         +  wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be
         +  sent when the user lifts the finger off the device.
         +
         +  If the source is wl_pointer axis_source.wheel or
         +  wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may
         +  or may not be sent. Whether a compositor sends an axis_stop event
         +  for these sources is hardware-specific and implementation-dependent;
         +  clients must not rely on receiving an axis_stop event for these
         +  scroll sources and should treat scroll sequences from these scroll
         +  sources as unterminated by default.
         +
         +  This event is optional. If the source is unknown for a particular
         +  axis event sequence, no event is sent.
         +  Only one wl_pointer.axis_source event is permitted per frame.
         +
         +  The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
         +  not guaranteed.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint axis_source) axis_source;
        /++
         +  axis stop event
         +
         +  Stop notification for scroll and other axes.
         +
         +  For some wl_pointer.axis_source types, a wl_pointer.axis_stop event
         +  is sent to notify a client that the axis sequence has terminated.
         +  This enables the client to implement kinetic scrolling.
         +  See the wl_pointer.axis_source documentation for information on when
         +  this event may be generated.
         +
         +  Any wl_pointer.axis events with the same axis_source after this
         +  event should be considered as the start of a new axis motion.
         +
         +  The timestamp is to be interpreted identical to the timestamp in the
         +  wl_pointer.axis event. The timestamp value may be the same as a
         +  preceding wl_pointer.axis event.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint time,
                       uint axis) axis_stop;
        /++
         +  axis click event
         +
         +  Discrete step information for scroll and other axes.
         +
         +  This event carries the axis value of the wl_pointer.axis event in
         +  discrete steps (e.g. mouse wheel clicks).
         +
         +  This event does not occur on its own, it is coupled with a
         +  wl_pointer.axis event that represents this axis value on a
         +  continuous scale. The protocol guarantees that each axis_discrete
         +  event is always followed by exactly one axis event with the same
         +  axis number within the same wl_pointer.frame. Note that the protocol
         +  allows for other events to occur between the axis_discrete and
         +  its coupled axis event, including other axis_discrete or axis
         +  events.
         +
         +  This event is optional; continuous scrolling devices
         +  like two-finger scrolling on touchpads do not have discrete
         +  steps and do not generate this event.
         +
         +  The discrete value carries the directional information. e.g. a value
         +  of -2 is two steps towards the negative direction of this axis.
         +
         +  The axis number is identical to the axis number in the associated
         +  axis event.
         +
         +  The order of wl_pointer.axis_discrete and wl_pointer.axis_source is
         +  not guaranteed.
         +/
        void function (void *data,
                       wl_pointer *wl_pointer,
                       uint axis,
                       int discrete) axis_discrete;
    }

    extern (D) int
    wl_pointer_add_listener(wl_pointer *wl_pointer,
                    const(wl_pointer_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_pointer,
                cast(Callback*)listener, data);
    }

    enum uint WL_POINTER_SET_CURSOR = 0;
    enum uint WL_POINTER_RELEASE = 1;

    extern (D) void
    wl_pointer_set_user_data(wl_pointer *wl_pointer, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_pointer, user_data);
    }

    extern (D) void *
    wl_pointer_get_user_data(wl_pointer *wl_pointer)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_pointer);
    }

    extern (D) void
    wl_pointer_destroy(wl_pointer *wl_pointer)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_pointer);
    }

    /++
     +  set the pointer surface
     +
     +  Set the pointer surface, i.e., the surface that contains the
     +  pointer image (cursor). This request gives the surface the role
     +  of a cursor. If the surface already has another role, it raises
     +  a protocol error.
     +
     +  The cursor actually changes only if the pointer
     +  focus for this device is one of the requesting client's surfaces
     +  or the surface parameter is the current pointer surface. If
     +  there was a previous surface set with this request it is
     +  replaced. If surface is NULL, the pointer image is hidden.
     +
     +  The parameters hotspot_x and hotspot_y define the position of
     +  the pointer surface relative to the pointer location. Its
     +  top-left corner is always at (x, y) - (hotspot_x, hotspot_y),
     +  where (x, y) are the coordinates of the pointer location, in
     +  surface-local coordinates.
     +
     +  On surface.attach requests to the pointer surface, hotspot_x
     +  and hotspot_y are decremented by the x and y parameters
     +  passed to the request. Attach must be confirmed by
     +  wl_surface.commit as usual.
     +
     +  The hotspot can also be updated by passing the currently set
     +  pointer surface to this request with new values for hotspot_x
     +  and hotspot_y.
     +
     +  The current and pending input regions of the wl_surface are
     +  cleared, and wl_surface.set_input_region is ignored until the
     +  wl_surface is no longer used as the cursor. When the use as a
     +  cursor ends, the current and pending input regions become
     +  undefined, and the wl_surface is unmapped.
     +/
    extern (D) void
    wl_pointer_set_cursor(wl_pointer *wl_pointer_, uint serial, wl_surface *surface, int hotspot_x, int hotspot_y)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_pointer_,
                WL_POINTER_SET_CURSOR, serial, surface, hotspot_x, hotspot_y);
    }

    /++
     +  release the pointer object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the pointer object anymore.
     +
     +  This request destroys the pointer proxy object, so clients must not call
     +  wl_pointer_destroy() after using this request.
     +/
    extern (D) void
    wl_pointer_release(wl_pointer *wl_pointer_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_pointer_,
                WL_POINTER_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_pointer_);
    }

    /++
     +  keyboard mapping format
     +
     +  This specifies the format of the keymap provided to the
     +  client with the wl_keyboard.keymap event.
     +/
    /++
     +  WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP: no keymap; client must understand how to interpret the raw keycode
     +  WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1: libxkbcommon compatible; to determine the xkb keycode, clients must add 8 to the key event keycode
     +
     +/
    enum uint WL_KEYBOARD_KEYMAP_FORMAT_NO_KEYMAP = 0;
    enum uint WL_KEYBOARD_KEYMAP_FORMAT_XKB_V1 = 1; /// ditto

    /++
     +  physical key state
     +
     +  Describes the physical state of a key that produced the key event.
     +/
    /++
     +  WL_KEYBOARD_KEY_STATE_RELEASED: key is not pressed
     +  WL_KEYBOARD_KEY_STATE_PRESSED: key is pressed
     +
     +/
    enum uint WL_KEYBOARD_KEY_STATE_RELEASED = 0;
    enum uint WL_KEYBOARD_KEY_STATE_PRESSED = 1; /// ditto

    /++
     +  keyboard input device
     +
     +  The wl_keyboard interface represents one or more keyboards
     +  associated with a seat.
     +/
    struct wl_keyboard_listener
    {
        /++
         +  keyboard mapping
         +
         +  This event provides a file descriptor to the client which can be
         +  memory-mapped to provide a keyboard mapping description.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       uint format,
                       int fd,
                       uint size) keymap;
        /++
         +  enter event
         +
         +  Notification that this seat's keyboard focus is on a certain
         +  surface.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       uint serial,
                       wl_surface *surface,
                       wl_array *keys) enter;
        /++
         +  leave event
         +
         +  Notification that this seat's keyboard focus is no longer on
         +  a certain surface.
         +
         +  The leave notification is sent before the enter notification
         +  for the new focus.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       uint serial,
                       wl_surface *surface) leave;
        /++
         +  key event
         +
         +  A key was pressed or released.
         +          The time argument is a timestamp with millisecond
         +          granularity, with an undefined base.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       uint serial,
                       uint time,
                       uint key,
                       uint state) key;
        /++
         +  modifier and group state
         +
         +  Notifies clients that the modifier and/or group state has
         +  changed, and it should update its local state.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       uint serial,
                       uint mods_depressed,
                       uint mods_latched,
                       uint mods_locked,
                       uint group) modifiers;
        /++
         +  repeat rate and delay
         +
         +  Informs the client about the keyboard's repeat rate and delay.
         +
         +  This event is sent as soon as the wl_keyboard object has been created,
         +  and is guaranteed to be received by the client before any key press
         +  event.
         +
         +  Negative values for either rate or delay are illegal. A rate of zero
         +  will disable any repeating (regardless of the value of delay).
         +
         +  This event can be sent later on as well with a new value if necessary,
         +  so clients should continue listening for the event past the creation
         +  of wl_keyboard.
         +/
        void function (void *data,
                       wl_keyboard *wl_keyboard,
                       int rate,
                       int delay) repeat_info;
    }

    extern (D) int
    wl_keyboard_add_listener(wl_keyboard *wl_keyboard,
                    const(wl_keyboard_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_keyboard,
                cast(Callback*)listener, data);
    }

    enum uint WL_KEYBOARD_RELEASE = 0;

    extern (D) void
    wl_keyboard_set_user_data(wl_keyboard *wl_keyboard, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_keyboard, user_data);
    }

    extern (D) void *
    wl_keyboard_get_user_data(wl_keyboard *wl_keyboard)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_keyboard);
    }

    extern (D) void
    wl_keyboard_destroy(wl_keyboard *wl_keyboard)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_keyboard);
    }

    /++
     +  release the keyboard object
     +
     +
     +/
    extern (D) void
    wl_keyboard_release(wl_keyboard *wl_keyboard_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_keyboard_,
                WL_KEYBOARD_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_keyboard_);
    }

    /++
     +  touchscreen input device
     +
     +  The wl_touch interface represents a touchscreen
     +  associated with a seat.
     +
     +  Touch interactions can consist of one or more contacts.
     +  For each contact, a series of events is generated, starting
     +  with a down event, followed by zero or more motion events,
     +  and ending with an up event. Events relating to the same
     +  contact point can be identified by the ID of the sequence.
     +/
    struct wl_touch_listener
    {
        /++
         +  touch down event and beginning of a touch sequence
         +
         +  A new touch point has appeared on the surface. This touch point is
         +  assigned a unique ID. Future events from this touch point reference
         +  this ID. The ID ceases to be valid after a touch up event and may be
         +  reused in the future.
         +/
        void function (void *data,
                       wl_touch *wl_touch,
                       uint serial,
                       uint time,
                       wl_surface *surface,
                       int id,
                       wl_fixed_t x,
                       wl_fixed_t y) down;
        /++
         +  end of a touch event sequence
         +
         +  The touch point has disappeared. No further events will be sent for
         +  this touch point and the touch point's ID is released and may be
         +  reused in a future touch down event.
         +/
        void function (void *data,
                       wl_touch *wl_touch,
                       uint serial,
                       uint time,
                       int id) up;
        /++
         +  update of touch point coordinates
         +
         +  A touch point has changed coordinates.
         +/
        void function (void *data,
                       wl_touch *wl_touch,
                       uint time,
                       int id,
                       wl_fixed_t x,
                       wl_fixed_t y) motion;
        /++
         +  end of touch frame event
         +
         +  Indicates the end of a contact point list.
         +/
        void function (void *data,
                       wl_touch *wl_touch) frame;
        /++
         +  touch session cancelled
         +
         +  Sent if the compositor decides the touch stream is a global
         +  gesture. No further events are sent to the clients from that
         +  particular gesture. Touch cancellation applies to all touch points
         +  currently active on this client's surface. The client is
         +  responsible for finalizing the touch points, future touch points on
         +  this surface may reuse the touch point ID.
         +/
        void function (void *data,
                       wl_touch *wl_touch) cancel;
    }

    extern (D) int
    wl_touch_add_listener(wl_touch *wl_touch,
                    const(wl_touch_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_touch,
                cast(Callback*)listener, data);
    }

    enum uint WL_TOUCH_RELEASE = 0;

    extern (D) void
    wl_touch_set_user_data(wl_touch *wl_touch, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_touch, user_data);
    }

    extern (D) void *
    wl_touch_get_user_data(wl_touch *wl_touch)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_touch);
    }

    extern (D) void
    wl_touch_destroy(wl_touch *wl_touch)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_touch);
    }

    /++
     +  release the touch object
     +
     +
     +/
    extern (D) void
    wl_touch_release(wl_touch *wl_touch_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_touch_,
                WL_TOUCH_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_touch_);
    }

    /++
     +  subpixel geometry information
     +
     +  This enumeration describes how the physical
     +  pixels on an output are laid out.
     +/
    /++
     +  WL_OUTPUT_SUBPIXEL_UNKNOWN: unknown geometry
     +  WL_OUTPUT_SUBPIXEL_NONE: no geometry
     +  WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB: horizontal RGB
     +  WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR: horizontal BGR
     +  WL_OUTPUT_SUBPIXEL_VERTICAL_RGB: vertical RGB
     +  WL_OUTPUT_SUBPIXEL_VERTICAL_BGR: vertical BGR
     +
     +/
    enum uint WL_OUTPUT_SUBPIXEL_UNKNOWN = 0;
    enum uint WL_OUTPUT_SUBPIXEL_NONE = 1; /// ditto
    enum uint WL_OUTPUT_SUBPIXEL_HORIZONTAL_RGB = 2; /// ditto
    enum uint WL_OUTPUT_SUBPIXEL_HORIZONTAL_BGR = 3; /// ditto
    enum uint WL_OUTPUT_SUBPIXEL_VERTICAL_RGB = 4; /// ditto
    enum uint WL_OUTPUT_SUBPIXEL_VERTICAL_BGR = 5; /// ditto

    /++
     +  transform from framebuffer to output
     +
     +  This describes the transform that a compositor will apply to a
     +  surface to compensate for the rotation or mirroring of an
     +  output device.
     +
     +  The flipped values correspond to an initial flip around a
     +  vertical axis followed by rotation.
     +
     +  The purpose is mainly to allow clients to render accordingly and
     +  tell the compositor, so that for fullscreen surfaces, the
     +  compositor will still be able to scan out directly from client
     +  surfaces.
     +/
    /++
     +  WL_OUTPUT_TRANSFORM_NORMAL: no transform
     +  WL_OUTPUT_TRANSFORM_90: 90 degrees counter-clockwise
     +  WL_OUTPUT_TRANSFORM_180: 180 degrees counter-clockwise
     +  WL_OUTPUT_TRANSFORM_270: 270 degrees counter-clockwise
     +  WL_OUTPUT_TRANSFORM_FLIPPED: 180 degree flip around a vertical axis
     +  WL_OUTPUT_TRANSFORM_FLIPPED_90: flip and rotate 90 degrees counter-clockwise
     +  WL_OUTPUT_TRANSFORM_FLIPPED_180: flip and rotate 180 degrees counter-clockwise
     +  WL_OUTPUT_TRANSFORM_FLIPPED_270: flip and rotate 270 degrees counter-clockwise
     +
     +/
    enum uint WL_OUTPUT_TRANSFORM_NORMAL = 0;
    enum uint WL_OUTPUT_TRANSFORM_90 = 1; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_180 = 2; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_270 = 3; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_FLIPPED = 4; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_FLIPPED_90 = 5; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_FLIPPED_180 = 6; /// ditto
    enum uint WL_OUTPUT_TRANSFORM_FLIPPED_270 = 7; /// ditto

    /++
     +  mode information
     +
     +  These flags describe properties of an output mode.
     +  They are used in the flags bitfield of the mode event.
     +/
    /++
     +  WL_OUTPUT_MODE_CURRENT: indicates this is the current mode
     +  WL_OUTPUT_MODE_PREFERRED: indicates this is the preferred mode
     +
     +/
    enum uint WL_OUTPUT_MODE_CURRENT = 0x1;
    enum uint WL_OUTPUT_MODE_PREFERRED = 0x2; /// ditto

    /++
     +  compositor output region
     +
     +  An output describes part of the compositor geometry.  The
     +  compositor works in the 'compositor coordinate system' and an
     +  output corresponds to a rectangular area in that space that is
     +  actually visible.  This typically corresponds to a monitor that
     +  displays part of the compositor space.  This object is published
     +  as global during start up, or when a monitor is hotplugged.
     +/
    struct wl_output_listener
    {
        /++
         +  properties of the output
         +
         +  The geometry event describes geometric properties of the output.
         +  The event is sent when binding to the output object and whenever
         +  any of the properties change.
         +/
        void function (void *data,
                       wl_output *wl_output,
                       int x,
                       int y,
                       int physical_width,
                       int physical_height,
                       int subpixel,
                       const(char) *make,
                       const(char) *model,
                       int transform) geometry;
        /++
         +  advertise available modes for the output
         +
         +  The mode event describes an available mode for the output.
         +
         +  The event is sent when binding to the output object and there
         +  will always be one mode, the current mode.  The event is sent
         +  again if an output changes mode, for the mode that is now
         +  current.  In other words, the current mode is always the last
         +  mode that was received with the current flag set.
         +
         +  The size of a mode is given in physical hardware units of
         +          the output device. This is not necessarily the same as
         +          the output size in the global compositor space. For instance,
         +          the output may be scaled, as described in wl_output.scale,
         +          or transformed, as described in wl_output.transform.
         +/
        void function (void *data,
                       wl_output *wl_output,
                       uint flags,
                       int width,
                       int height,
                       int refresh) mode;
        /++
         +  sent all information about output
         +
         +  This event is sent after all other properties have been
         +  sent after binding to the output object and after any
         +  other property changes done after that. This allows
         +  changes to the output properties to be seen as
         +  atomic, even if they happen via multiple events.
         +/
        void function (void *data,
                       wl_output *wl_output) done;
        /++
         +  output scaling properties
         +
         +  This event contains scaling geometry information
         +          that is not in the geometry event. It may be sent after
         +          binding the output object or if the output scale changes
         +          later. If it is not sent, the client should assume a
         +  scale of 1.
         +
         +  A scale larger than 1 means that the compositor will
         +  automatically scale surface buffers by this amount
         +  when rendering. This is used for very high resolution
         +  displays where applications rendering at the native
         +  resolution would be too small to be legible.
         +
         +  It is intended that scaling aware clients track the
         +  current output of a surface, and if it is on a scaled
         +  output it should use wl_surface.set_buffer_scale with
         +  the scale of the output. That way the compositor can
         +  avoid scaling the surface, and the client can supply
         +  a higher detail image.
         +/
        void function (void *data,
                       wl_output *wl_output,
                       int factor) scale;
    }

    extern (D) int
    wl_output_add_listener(wl_output *wl_output,
                    const(wl_output_listener) *listener, void *data)
    {
        alias Callback = extern (C) void function();

        return wl_proxy_add_listener(
                cast(wl_proxy*)wl_output,
                cast(Callback*)listener, data);
    }

    enum uint WL_OUTPUT_RELEASE = 0;

    extern (D) void
    wl_output_set_user_data(wl_output *wl_output, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_output, user_data);
    }

    extern (D) void *
    wl_output_get_user_data(wl_output *wl_output)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_output);
    }

    extern (D) void
    wl_output_destroy(wl_output *wl_output)
    {
        wl_proxy_destroy(cast(wl_proxy*) wl_output);
    }

    /++
     +  release the output object
     +
     +  Using this request a client can tell the server that it is not going to
     +  use the output object anymore.
     +/
    extern (D) void
    wl_output_release(wl_output *wl_output_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_output_,
                WL_OUTPUT_RELEASE);

        wl_proxy_destroy(cast(wl_proxy*) wl_output_);
    }

    enum uint WL_REGION_DESTROY = 0;
    enum uint WL_REGION_ADD = 1;
    enum uint WL_REGION_SUBTRACT = 2;

    extern (D) void
    wl_region_set_user_data(wl_region *wl_region, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_region, user_data);
    }

    extern (D) void *
    wl_region_get_user_data(wl_region *wl_region)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_region);
    }

    /++
     +  destroy region
     +
     +  Destroy the region.  This will invalidate the object ID.
     +/
    extern (D) void
    wl_region_destroy(wl_region *wl_region_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_region_,
                WL_REGION_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_region_);
    }

    /++
     +  add rectangle to region
     +
     +  Add the specified rectangle to the region.
     +/
    extern (D) void
    wl_region_add(wl_region *wl_region_, int x, int y, int width, int height)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_region_,
                WL_REGION_ADD, x, y, width, height);
    }

    /++
     +  subtract rectangle from region
     +
     +  Subtract the specified rectangle from the region.
     +/
    extern (D) void
    wl_region_subtract(wl_region *wl_region_, int x, int y, int width, int height)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_region_,
                WL_REGION_SUBTRACT, x, y, width, height);
    }

    /++
     +  WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE: the to-be sub-surface is invalid
     +
     +/
    enum uint WL_SUBCOMPOSITOR_ERROR_BAD_SURFACE = 0;

    enum uint WL_SUBCOMPOSITOR_DESTROY = 0;
    enum uint WL_SUBCOMPOSITOR_GET_SUBSURFACE = 1;

    extern (D) void
    wl_subcompositor_set_user_data(wl_subcompositor *wl_subcompositor, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_subcompositor, user_data);
    }

    extern (D) void *
    wl_subcompositor_get_user_data(wl_subcompositor *wl_subcompositor)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_subcompositor);
    }

    /++
     +  unbind from the subcompositor interface
     +
     +  Informs the server that the client will not be using this
     +  protocol object anymore. This does not affect any other
     +  objects, wl_subsurface objects included.
     +/
    extern (D) void
    wl_subcompositor_destroy(wl_subcompositor *wl_subcompositor_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subcompositor_,
                WL_SUBCOMPOSITOR_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_subcompositor_);
    }

    /++
     +  give a surface the role sub-surface
     +
     +  Create a sub-surface interface for the given surface, and
     +  associate it with the given parent surface. This turns a
     +  plain wl_surface into a sub-surface.
     +
     +  The to-be sub-surface must not already have another role, and it
     +  must not have an existing wl_subsurface object. Otherwise a protocol
     +  error is raised.
     +/
    extern (D) wl_subsurface *
    wl_subcompositor_get_subsurface(wl_subcompositor *wl_subcompositor_, wl_surface *surface, wl_surface *parent)
    {
        wl_proxy *id;

        id = wl_proxy_marshal_constructor(
                cast(wl_proxy*) wl_subcompositor_,
                WL_SUBCOMPOSITOR_GET_SUBSURFACE, wl_subsurface_interface, null, surface, parent);

        return cast(wl_subsurface *) id;
    }

    /++
     +  WL_SUBSURFACE_ERROR_BAD_SURFACE: wl_surface is not a sibling or the parent
     +
     +/
    enum uint WL_SUBSURFACE_ERROR_BAD_SURFACE = 0;

    enum uint WL_SUBSURFACE_DESTROY = 0;
    enum uint WL_SUBSURFACE_SET_POSITION = 1;
    enum uint WL_SUBSURFACE_PLACE_ABOVE = 2;
    enum uint WL_SUBSURFACE_PLACE_BELOW = 3;
    enum uint WL_SUBSURFACE_SET_SYNC = 4;
    enum uint WL_SUBSURFACE_SET_DESYNC = 5;

    extern (D) void
    wl_subsurface_set_user_data(wl_subsurface *wl_subsurface, void *user_data)
    {
        wl_proxy_set_user_data(cast(wl_proxy*) wl_subsurface, user_data);
    }

    extern (D) void *
    wl_subsurface_get_user_data(wl_subsurface *wl_subsurface)
    {
        return wl_proxy_get_user_data(cast(wl_proxy*) wl_subsurface);
    }

    /++
     +  remove sub-surface interface
     +
     +  The sub-surface interface is removed from the wl_surface object
     +  that was turned into a sub-surface with a
     +  wl_subcompositor.get_subsurface request. The wl_surface's association
     +  to the parent is deleted, and the wl_surface loses its role as
     +  a sub-surface. The wl_surface is unmapped.
     +/
    extern (D) void
    wl_subsurface_destroy(wl_subsurface *wl_subsurface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_DESTROY);

        wl_proxy_destroy(cast(wl_proxy*) wl_subsurface_);
    }

    /++
     +  reposition the sub-surface
     +
     +  This schedules a sub-surface position change.
     +  The sub-surface will be moved so that its origin (top left
     +  corner pixel) will be at the location x, y of the parent surface
     +  coordinate system. The coordinates are not restricted to the parent
     +  surface area. Negative values are allowed.
     +
     +  The scheduled coordinates will take effect whenever the state of the
     +  parent surface is applied. When this happens depends on whether the
     +  parent surface is in synchronized mode or not. See
     +  wl_subsurface.set_sync and wl_subsurface.set_desync for details.
     +
     +  If more than one set_position request is invoked by the client before
     +  the commit of the parent surface, the position of a new request always
     +  replaces the scheduled position from any previous request.
     +
     +  The initial position is 0, 0.
     +/
    extern (D) void
    wl_subsurface_set_position(wl_subsurface *wl_subsurface_, int x, int y)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_SET_POSITION, x, y);
    }

    /++
     +  restack the sub-surface
     +
     +  This sub-surface is taken from the stack, and put back just
     +  above the reference surface, changing the z-order of the sub-surfaces.
     +  The reference surface must be one of the sibling surfaces, or the
     +  parent surface. Using any other surface, including this sub-surface,
     +  will cause a protocol error.
     +
     +  The z-order is double-buffered. Requests are handled in order and
     +  applied immediately to a pending state. The final pending state is
     +  copied to the active state the next time the state of the parent
     +  surface is applied. When this happens depends on whether the parent
     +  surface is in synchronized mode or not. See wl_subsurface.set_sync and
     +  wl_subsurface.set_desync for details.
     +
     +  A new sub-surface is initially added as the top-most in the stack
     +  of its siblings and parent.
     +/
    extern (D) void
    wl_subsurface_place_above(wl_subsurface *wl_subsurface_, wl_surface *sibling)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_PLACE_ABOVE, sibling);
    }

    /++
     +  restack the sub-surface
     +
     +  The sub-surface is placed just below the reference surface.
     +  See wl_subsurface.place_above.
     +/
    extern (D) void
    wl_subsurface_place_below(wl_subsurface *wl_subsurface_, wl_surface *sibling)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_PLACE_BELOW, sibling);
    }

    /++
     +  set sub-surface to synchronized mode
     +
     +  Change the commit behaviour of the sub-surface to synchronized
     +  mode, also described as the parent dependent mode.
     +
     +  In synchronized mode, wl_surface.commit on a sub-surface will
     +  accumulate the committed state in a cache, but the state will
     +  not be applied and hence will not change the compositor output.
     +  The cached state is applied to the sub-surface immediately after
     +  the parent surface's state is applied. This ensures atomic
     +  updates of the parent and all its synchronized sub-surfaces.
     +  Applying the cached state will invalidate the cache, so further
     +  parent surface commits do not (re-)apply old state.
     +
     +  See wl_subsurface for the recursive effect of this mode.
     +/
    extern (D) void
    wl_subsurface_set_sync(wl_subsurface *wl_subsurface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_SET_SYNC);
    }

    /++
     +  set sub-surface to desynchronized mode
     +
     +  Change the commit behaviour of the sub-surface to desynchronized
     +  mode, also described as independent or freely running mode.
     +
     +  In desynchronized mode, wl_surface.commit on a sub-surface will
     +  apply the pending state directly, without caching, as happens
     +  normally with a wl_surface. Calling wl_surface.commit on the
     +  parent surface has no effect on the sub-surface's wl_surface
     +  state. This mode allows a sub-surface to be updated on its own.
     +
     +  If cached state exists when wl_surface.commit is called in
     +  desynchronized mode, the pending state is added to the cached
     +  state, and applied as a whole. This invalidates the cache.
     +
     +  Note: even if a sub-surface is set to desynchronized, a parent
     +  sub-surface may override it to behave as synchronized. For details,
     +  see wl_subsurface.
     +
     +  If a surface's parent surface behaves as desynchronized, then
     +  the cached state is applied on set_desync.
     +/
    extern (D) void
    wl_subsurface_set_desync(wl_subsurface *wl_subsurface_)
    {
        wl_proxy_marshal(cast(wl_proxy*) wl_subsurface_,
                WL_SUBSURFACE_SET_DESYNC);
    }


} // extern (C)

